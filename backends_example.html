

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>TKET Backend Tutorial &#8212; pytket examples</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'backends_example';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Comparison of the simulators available through tket" href="comparing_simulators.html" />
    <link rel="prev" title="Benchmarking" href="benchmarking/README.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="README.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/Quantinuum_logo_black.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/Quantinuum_logo_white.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ansatz_sequence_example.html">Ansatz Sequencing</a></li>
<li class="toctree-l1"><a class="reference internal" href="circuit_analysis_example.html">Circuit analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="circuit_generation_example.html">Circuit generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="compilation_example.html">Compilation passes</a></li>
<li class="toctree-l1"><a class="reference internal" href="conditional_gate_example.html">Conditional Execution</a></li>
<li class="toctree-l1"><a class="reference internal" href="contextual_optimization.html">Contextual optimisation</a></li>
<li class="toctree-l1"><a class="reference internal" href="creating_backends.html">How to create your own <code class="docutils literal notranslate"><span class="pre">Backend</span></code> using <code class="docutils literal notranslate"><span class="pre">pytket</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="measurement_reduction_example.html">Advanced Expectation Values and Measurement Reduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="mapping_example.html">Qubit Mapping and Routing</a></li>
<li class="toctree-l1"><a class="reference internal" href="symbolics_example.html">Symbolic compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="ucc_vqe.html">VQE for Unitary Coupled Cluster using tket</a></li>
<li class="toctree-l1"><a class="reference internal" href="pytket-qujax_qaoa.html">Symbolic circuits with <code class="docutils literal notranslate"><span class="pre">qujax</span></code> and <code class="docutils literal notranslate"><span class="pre">pytket-qujax</span></code><br/></a></li>



<li class="toctree-l1"><a class="reference internal" href="benchmarking/README.html">Benchmarking</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">TKET Backend Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="comparing_simulators.html">Comparison of the simulators available through tket</a></li>
<li class="toctree-l1"><a class="reference internal" href="qiskit_integration.html">Integrating <code class="docutils literal notranslate"><span class="pre">pytket</span></code> into Qiskit software</a></li>
<li class="toctree-l1"><a class="reference internal" href="Forest_portability_example.html">Code Portability and Intro to Forest</a></li>
<li class="toctree-l1"><a class="reference internal" href="pytket-qujax-classification.html">Binary Classification using pytket-qujax</a></li>




<li class="toctree-l1"><a class="reference internal" href="expectation_value_example.html">Expectation Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="entanglement_swapping.html">Iterated Entanglement Swapping using tket</a></li>
<li class="toctree-l1"><a class="reference internal" href="pytket-qujax_heisenberg_vqe.html">Let’s start with a tket circuit<br/></a></li>





<li class="toctree-l1"><a class="reference internal" href="spam_example.html">Calibration and Correction of State Preparation and Measurement (SPAM)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tket_benchmarking.html">tket benchmarking example</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/backends_example.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>TKET Backend Tutorial</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="tket-backend-tutorial">
<h1>TKET Backend Tutorial<a class="headerlink" href="#tket-backend-tutorial" title="Permalink to this heading">#</a></h1>
<p>This example shows how to use <code class="docutils literal notranslate"><span class="pre">pytket</span></code> to execute quantum circuits on both simulators and real devices, and how to interpret the results. As tket is designed to be platform-agnostic, we have unified the interfaces of different providers as much as possible into the <code class="docutils literal notranslate"><span class="pre">Backend</span></code> class for maximum portability of code. The following is a selection of currently supported backends:<br></p>
<ul class="simple">
<li><p>ProjectQ simulator<br></p></li>
<li><p>Aer simulators (statevector, QASM, and unitary)<br></p></li>
<li><p>IBMQ devices<br></p></li>
<li><p>Rigetti QCS devices<br></p></li>
<li><p>Rigetti QVM (for device simulation or statevector)<br></p></li>
<li><p>AQT devices<br></p></li>
<li><p>Quantinuum devices<br></p></li>
<li><p>Q# simulators</p></li>
</ul>
<p>In this notebook we will focus on the Aer, IBMQ and ProjectQ backends.<br>
<br>
To get started, we must install the core pytket package and the subpackages required to interface with the desired providers. We will also need the <code class="docutils literal notranslate"><span class="pre">QubitOperator</span></code> class from <code class="docutils literal notranslate"><span class="pre">openfermion</span></code> to construct operators for a later example. To get everything run the following in shell:<br>
<br>
<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pytket</span> <span class="pre">pytket-qiskit</span> <span class="pre">pytket-projectq</span> <span class="pre">openfermion</span></code><br>
<br>
First, import the backends that we will be demonstrating.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AerStateBackend</span><span class="p">,</span>
    <span class="n">AerBackend</span><span class="p">,</span>
    <span class="n">AerUnitaryBackend</span><span class="p">,</span>
    <span class="n">IBMQBackend</span><span class="p">,</span>
    <span class="n">IBMQEmulatorBackend</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pytket.extensions.projectq</span> <span class="kn">import</span> <span class="n">ProjectQBackend</span>
</pre></div>
</div>
</div>
</div>
<p>We are also going to be making a circuit to run on these backends, so import the <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> class.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span>
</pre></div>
</div>
</div>
</div>
<p>Below we generate a circuit which will produce a Bell state, assuming the qubits are all initialised in the |0&gt; state:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As a sanity check, we will use the <code class="docutils literal notranslate"><span class="pre">AerStateBackend</span></code> to verify that <code class="docutils literal notranslate"><span class="pre">circ</span></code> does actually produce a Bell state.<br>
<br>
To submit a circuit for excution on a backend we can use <code class="docutils literal notranslate"><span class="pre">process_circuit</span></code> with appropriate arguments. If we have multiple circuits to excecute, we can use <code class="docutils literal notranslate"><span class="pre">process_circuits</span></code> (note the plural), which will attempt to batch up the circuits if possible. Both methods return a <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> object per submitted <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> which you can use with result retrieval methods to get the result type you want (as long as that result type is supported by the backend).<br>
<br>
Calling <code class="docutils literal notranslate"><span class="pre">get_state</span></code> will return a <code class="docutils literal notranslate"><span class="pre">numpy</span></code> array corresponding to the statevector.<br>
<br>
This style of usage is used consistently in the <code class="docutils literal notranslate"><span class="pre">pytket</span></code> backends.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">aer_state_b</span> <span class="o">=</span> <span class="n">AerStateBackend</span><span class="p">()</span>
<span class="n">state_handle</span> <span class="o">=</span> <span class="n">aer_state_b</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="n">statevector</span> <span class="o">=</span> <span class="n">aer_state_b</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">state_handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_state</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">statevector</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>As we can see, the output state vector <span class="math notranslate nohighlight">\(\lvert \psi_{\mathrm{circ}}\rangle\)</span> is <span class="math notranslate nohighlight">\((\lvert00\rangle + \lvert11\rangle)/\sqrt2\)</span>.<br>
<br>
This is a symmetric state. For non-symmetric states, we default to an ILO-BE format (increasing lexicographic order of (qu)bit ids, big-endian), but an alternative convention can be specified when retrieving results from backends. See the docs for the <code class="docutils literal notranslate"><span class="pre">BasisOrder</span></code> enum for more information.</p>
<p>A lesser-used simulator available through Qiskit Aer is their unitary simulator. This will be somewhat more expensive to run, but returns the full unitary matrix for the provided circuit. This is useful in the design of small subcircuits that will be used multiple times within other larger circuits - statevector simulators will only test that they act correctly on the <span class="math notranslate nohighlight">\(\lvert 0 \rangle^{\otimes n}\)</span> state, which is not enough to guarantee the circuit’s correctness.<br>
<br>
The <code class="docutils literal notranslate"><span class="pre">AerUnitaryBackend</span></code> provides a convenient access point for this simulator for use with <code class="docutils literal notranslate"><span class="pre">pytket</span></code> circuits. The unitary of the circuit can be retrieved from backends that support it using the <code class="docutils literal notranslate"><span class="pre">BackendResult.get_unitary</span></code> interface. In this example, we chose to use <code class="docutils literal notranslate"><span class="pre">Backend.run_circuit</span></code>, which is equivalent to calling <code class="docutils literal notranslate"><span class="pre">process_circuit</span></code> followed by <code class="docutils literal notranslate"><span class="pre">get_result</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">aer_unitary_b</span> <span class="o">=</span> <span class="n">AerUnitaryBackend</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">aer_unitary_b</span><span class="o">.</span><span class="n">run_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>Note that state vector and unitary simulations are also available in pytket directly. In general, we recommend you use these unless you require another Backend explicitly.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">statevector</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Now suppose we want to measure this Bell state to get some actual results out, so let’s append some <code class="docutils literal notranslate"><span class="pre">Measure</span></code> gates to the circuit. The <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> class has the <code class="docutils literal notranslate"><span class="pre">measure_all</span></code> utility function which appends <code class="docutils literal notranslate"><span class="pre">Measure</span></code> gates on every qubit. All of these results will be written to the default classical register (‘c’). This function will automatically add the classical bits to the circuit if they are not already there.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>We can get some measured counts out from the <code class="docutils literal notranslate"><span class="pre">AerBackend</span></code>, which is an interface to the Qiskit Aer QASM simulator. Suppose we would like to get 10 shots out (10 repeats of the circuit and measurement). We can seed the simulator’s random-number generator in order to make the results reproducible, using an optional keyword argument to <code class="docutils literal notranslate"><span class="pre">process_circuit</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">aer_b</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">()</span>
<span class="n">handle</span> <span class="o">=</span> <span class="n">aer_b</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">counts</span> <span class="o">=</span> <span class="n">aer_b</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>What happens if we simulate some noise in our imagined device, using the Qiskit Aer noise model?</p>
<p>To investigate this, we will require an import from Qiskit. For more information about noise modelling using Qiskit Aer, see the <a class="reference external" href="https://qiskit.org/documentation/apidoc/aer_noise.html">Qiskit device noise</a> documentation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit.providers.aer.noise</span> <span class="kn">import</span> <span class="n">NoiseModel</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">my_noise_model</span> <span class="o">=</span> <span class="n">NoiseModel</span><span class="p">()</span>
<span class="n">readout_error</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">my_noise_model</span><span class="o">.</span><span class="n">add_readout_error</span><span class="p">(</span>
        <span class="p">[[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">readout_error</span><span class="p">,</span> <span class="n">readout_error</span><span class="p">],</span> <span class="p">[</span><span class="n">readout_error</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">readout_error</span><span class="p">]],</span> <span class="p">[</span><span class="n">q</span><span class="p">]</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>This simple noise model gives a 20% chance that, upon measurement, a qubit that would otherwise have been measured as <span class="math notranslate nohighlight">\(0\)</span> would instead be measured as <span class="math notranslate nohighlight">\(1\)</span>, and vice versa. Let’s see what our shot table looks like with this model:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noisy_aer_b</span> <span class="o">=</span> <span class="n">AerBackend</span><span class="p">(</span><span class="n">my_noise_model</span><span class="p">)</span>
<span class="n">noisy_handle</span> <span class="o">=</span> <span class="n">noisy_aer_b</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">valid_check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">noisy_counts</span> <span class="o">=</span> <span class="n">noisy_aer_b</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">noisy_handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">noisy_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We now have some spurious <span class="math notranslate nohighlight">\(01\)</span> and <span class="math notranslate nohighlight">\(10\)</span> measurements, which could never happen when measuring a Bell state on a noiseless device.<br>
<br>
The <code class="docutils literal notranslate"><span class="pre">AerBackend</span></code> class can accept any Qiskit noise model.<br>
<br>
All backends expose a generic <code class="docutils literal notranslate"><span class="pre">get_result</span></code> method which takes a <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> and returns the respective result in the form of a <code class="docutils literal notranslate"><span class="pre">BackendResult</span></code> object. This object may hold measured results in the form of shots or counts, or an exact statevector from simulation. Measured results are stored as <code class="docutils literal notranslate"><span class="pre">OutcomeArray</span></code> objects, which compresses measured bit values into 8-bit integers. We can extract the bitwise values using <code class="docutils literal notranslate"><span class="pre">to_readouts</span></code>.<br>
<br>
Instead of an assumed ILO or DLO convention, we can use this object to request only the <code class="docutils literal notranslate"><span class="pre">Bit</span></code> measurements we want, in the order we want. Let’s try reversing the bits of the noisy results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">backend_result</span> <span class="o">=</span> <span class="n">noisy_aer_b</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">noisy_handle</span><span class="p">)</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">bits</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">outcomes</span> <span class="o">=</span> <span class="n">backend_result</span><span class="o">.</span><span class="n">get_counts</span><span class="p">([</span><span class="n">bits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">outcomes</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">BackendResult</span></code> objects can be natively serialized to and deserialized from a dictionary. This dictionary can be immediately dumped to <code class="docutils literal notranslate"><span class="pre">json</span></code> for storing results.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.backends.backendresult</span> <span class="kn">import</span> <span class="n">BackendResult</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result_dict</span> <span class="o">=</span> <span class="n">backend_result</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">BackendResult</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">result_dict</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>The last simulator we will demonstrate is the <code class="docutils literal notranslate"><span class="pre">ProjectQBackend</span></code>. ProjectQ offers fast simulation of quantum circuits with built-in support for fast expectation values from operators. The <code class="docutils literal notranslate"><span class="pre">ProjectQBackend</span></code> exposes this functionality to take in OpenFermion <code class="docutils literal notranslate"><span class="pre">QubitOperator</span></code> instances. These are convertible to and from <code class="docutils literal notranslate"><span class="pre">QubitPauliOperator</span></code> instances in Pytket.<br>
<br>
Note: ProjectQ can also produce statevectors in the style of <code class="docutils literal notranslate"><span class="pre">AerStateBackend</span></code>, and similarly Aer backends can calculate expectation values directly, consult the relevant documentation to see more.<br>
<br>
Let’s create an OpenFermion <code class="docutils literal notranslate"><span class="pre">QubitOperator</span></code> object and a new circuit:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">openfermion</span> <span class="k">as</span> <span class="nn">of</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">of</span><span class="o">.</span><span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;X0 X2&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">of</span><span class="o">.</span><span class="n">QubitOperator</span><span class="p">(</span><span class="s2">&quot;Z0&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ2</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We convert the OpenFermion Hamiltonian into a pytket QubitPauliOperator:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span><span class="p">,</span> <span class="n">QubitPauliString</span>
<span class="kn">from</span> <span class="nn">pytket.utils.operators</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pauli_sym</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;I&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qps_from_openfermion</span><span class="p">(</span><span class="n">paulis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert OpenFermion tensor of Paulis to pytket QubitPauliString.&quot;&quot;&quot;</span>
    <span class="n">qlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paulis</span><span class="p">:</span>
        <span class="n">qlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">plist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pauli_sym</span><span class="p">[</span><span class="n">p</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">QubitPauliString</span><span class="p">(</span><span class="n">qlist</span><span class="p">,</span> <span class="n">plist</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">qpo_from_openfermion</span><span class="p">(</span><span class="n">openf_op</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert OpenFermion QubitOperator to pytket QubitPauliOperator.&quot;&quot;&quot;</span>
    <span class="n">tk_op</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">openf_op</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">qps_from_openfermion</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
        <span class="n">tk_op</span><span class="p">[</span><span class="n">string</span><span class="p">]</span> <span class="o">=</span> <span class="n">coeff</span>
    <span class="k">return</span> <span class="n">QubitPauliOperator</span><span class="p">(</span><span class="n">tk_op</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">hamiltonian_op</span> <span class="o">=</span> <span class="n">qpo_from_openfermion</span><span class="p">(</span><span class="n">hamiltonian</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now we can create a <code class="docutils literal notranslate"><span class="pre">ProjectQBackend</span></code> instance and feed it our circuit and <code class="docutils literal notranslate"><span class="pre">QubitOperator</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.utils.operators</span> <span class="kn">import</span> <span class="n">QubitPauliOperator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">projectq_b</span> <span class="o">=</span> <span class="n">ProjectQBackend</span><span class="p">()</span>
<span class="n">expectation</span> <span class="o">=</span> <span class="n">projectq_b</span><span class="o">.</span><span class="n">get_operator_expectation_value</span><span class="p">(</span><span class="n">circ2</span><span class="p">,</span> <span class="n">hamiltonian_op</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expectation</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The last leg of this tour includes running a pytket circuit on an actual quantum computer. To do this, you will need an IBM quantum experience account and have your credentials stored on your computer. See <a class="reference external" href="https://quantum-computing.ibm.com">https://quantum-computing.ibm.com</a> to make an account and view available devices and their specs.<br>
<br>
Physical devices have much stronger constraints on the form of admissible circuits than simulators. They tend to support a minimal gate set, have restricted connectivity between qubits for two-qubit gates, and can have limited support for classical control flow or conditional gates. This is where we can invoke the tket compiler passes to transform our desired circuit into one that is suitable for the backend.<br>
<br>
To check our code works correctly, we can use the <code class="docutils literal notranslate"><span class="pre">IBMQEmulatorBackend</span></code> to run our code exactly as if it were going to run on a real device, but just execute on a simulator (with a basic noise model adapted from the reported device properties).</p>
<p>Let’s create an <code class="docutils literal notranslate"><span class="pre">IBMQEmulatorBackend</span></code> for the <code class="docutils literal notranslate"><span class="pre">ibmq_manila</span></code> device and check if our circuit is valid to be run.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ibmq_b_emu</span> <span class="o">=</span> <span class="n">IBMQEmulatorBackend</span><span class="p">(</span><span class="s2">&quot;ibmq_manila&quot;</span><span class="p">)</span>
<span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">valid_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>It looks like we need to compile this circuit to be compatible with the device. To simplify this procedure, we provide minimal compilation passes designed for each backend (the <code class="docutils literal notranslate"><span class="pre">default_compilation_pass()</span></code> method) which will guarantee compatibility with the device. These may still fail if the input circuit has too many qubits or unsupported usage of conditional gates. The default passes can have their degree of optimisation by changing an integer parameter (optimisation levels 0, 1, 2), and they can be easily composed with any of tket’s other optimisation passes for better performance.<br>
<br>
For convenience, we also wrap up this pass into the <code class="docutils literal notranslate"><span class="pre">get_compiled_circuit</span></code> method if you just want to compile a single circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">compiled_circ</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s create a backend for running on the actual device and check our compiled circuit is valid for this backend too.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ibmq_b</span> <span class="o">=</span> <span class="n">IBMQBackend</span><span class="p">(</span><span class="s2">&quot;ibmq_manila&quot;</span><span class="p">)</span>
<span class="n">ibmq_b</span><span class="o">.</span><span class="n">valid_circuit</span><span class="p">(</span><span class="n">compiled_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We are now good to run this circuit on the device. After submitting, we can use the handle to check on the status of the job, so that we know when results are ready to be retrieved. The <code class="docutils literal notranslate"><span class="pre">circuit_status</span></code> method works for all backends, and returns a <code class="docutils literal notranslate"><span class="pre">CircuitStatus</span></code> object. If we just run <code class="docutils literal notranslate"><span class="pre">get_result</span></code> straight away, the backend will wait for results to complete, blocking any other code from running.<br>
<br>
In this notebook we will use the emulated backend <code class="docutils literal notranslate"><span class="pre">ibmq_b_emu</span></code> to illustrate, but the workflow is the same as for the real backend <code class="docutils literal notranslate"><span class="pre">ibmq_b</span></code> (except that the latter will typically take much longer because of the size of the queue).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quantum_handle</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">compiled_circ</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">circuit_status</span><span class="p">(</span><span class="n">quantum_handle</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">quantum_counts</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">quantum_handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">quantum_counts</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>These are from an actual device, so it’s impossible to perfectly predict what the results will be. However, because of the problem of noise, it would be unsurprising to find a few <span class="math notranslate nohighlight">\(01\)</span> or <span class="math notranslate nohighlight">\(10\)</span> results in the table. The circuit is very short, so it should be fairly close to the ideal result.<br>
<br>
The devices available through the IBM Q Experience serve jobs one at a time from their respective queues, so a large amount of experiment time can be taken up by waiting for your jobs to reach the front of the queue. <code class="docutils literal notranslate"><span class="pre">pytket</span></code> allows circuits to be submitted to any backend in a single batch using the <code class="docutils literal notranslate"><span class="pre">process_circuits</span></code> method. For the <code class="docutils literal notranslate"><span class="pre">IBMQBackend</span></code>, this will collate the circuits into as few jobs as possible which will all be sent off into the queue for the device. The method returns a <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> per submitted circuit, in the order of submission.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuits</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
    <span class="n">circuits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
<span class="n">handles</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">process_circuits</span><span class="p">(</span><span class="n">circuits</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">handles</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can now retrieve the results and process them. As we measured each circuit in the <span class="math notranslate nohighlight">\(Z\)</span>-basis, we can obtain the expectation value for the <span class="math notranslate nohighlight">\(ZZ\)</span> operator immediately from these measurement results. We can calculate this using the <code class="docutils literal notranslate"><span class="pre">expectation_from_counts</span></code> utility method in <code class="docutils literal notranslate"><span class="pre">pytket</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">expectation_from_counts</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">()</span>
    <span class="n">exp_val</span> <span class="o">=</span> <span class="n">expectation_from_counts</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">exp_val</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> can be easily stored in its string representaton and later reconstructed using the <code class="docutils literal notranslate"><span class="pre">from_str</span></code> method. For example, we could do something like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.backends</span> <span class="kn">import</span> <span class="n">ResultHandle</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_compiled_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">handle</span> <span class="o">=</span> <span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">process_circuit</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">handlestring</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">handlestring</span><span class="p">)</span>
<span class="c1"># ... later ...</span>
<span class="n">oldhandle</span> <span class="o">=</span> <span class="n">ResultHandle</span><span class="o">.</span><span class="n">from_str</span><span class="p">(</span><span class="n">handlestring</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ibmq_b_emu</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">oldhandle</span><span class="p">)</span><span class="o">.</span><span class="n">get_counts</span><span class="p">())</span>
</pre></div>
</div>
</div>
</div>
<p>For backends which support persistent handles (e.g. <code class="docutils literal notranslate"><span class="pre">IBMQBackend</span></code>, <code class="docutils literal notranslate"><span class="pre">QuantinuumBackend</span></code>, <code class="docutils literal notranslate"><span class="pre">BraketBackend</span></code> and <code class="docutils literal notranslate"><span class="pre">AQTBackend</span></code>) you can even stop your python session and use your result handles in a separate script to retrive results when they are ready, by storing the handle strings. For experiments with long queue times, this enables separate job submission and retrieval. Use <code class="docutils literal notranslate"><span class="pre">Backend.persistent_handles</span></code> to check whether a backend supports this feature.<br>
<br>
All backends will also cache all results obtained in the current python session, so you can use the <code class="docutils literal notranslate"><span class="pre">ResultHandle</span></code> to retrieve the results many times if you need to reuse the results. Over a long experiment, this can consume a large amount of RAM, so we recommend removing results from the cache when you are done with them. A simple way to achieve this is by calling <code class="docutils literal notranslate"><span class="pre">Backend.empty_cache</span></code> (e.g. at the end of each loop of a variational algorithm), or removing individual results with <code class="docutils literal notranslate"><span class="pre">Backend.pop_result</span></code>.</p>
<p>The backends in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> are designed to be as similar to one another as possible. The example above using physical devices can be run entirely on a simulator by swapping out the <code class="docutils literal notranslate"><span class="pre">IBMQBackend</span></code> constructor for any other backend supporting shot outputs (e.g. <code class="docutils literal notranslate"><span class="pre">AerBackend</span></code>, <code class="docutils literal notranslate"><span class="pre">ProjectQBackend</span></code>, <code class="docutils literal notranslate"><span class="pre">ForestBackend</span></code>), or passing it the name of a different device. Furthermore, using pytket it is simple to convert between handling shot tables, counts maps and statevectors.<br>
<br>
For more information on backends and other <code class="docutils literal notranslate"><span class="pre">pytket</span></code> features, read our <a class="reference external" href="https://cqcl.github.io/pytket">documentation</a> or see the other examples on our <a class="reference external" href="https://github.com/CQCL/tket/pytket/api">GitHub repo</a>.</p>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="benchmarking/README.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Benchmarking</p>
      </div>
    </a>
    <a class="right-next"
       href="comparing_simulators.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Comparison of the simulators available through tket</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By The Jupyter Book community
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2022.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>