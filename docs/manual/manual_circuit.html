

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Circuit Construction &#8212; pytket user manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/thebelab-helper.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'manual_circuit';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Running on Backends" href="manual_backend.html" />
    <link rel="prev" title="What is tket?" href="manual_intro.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/Quantinuum_logo_black.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/Quantinuum_logo_white.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Manual Sections:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="manual_intro.html">What is tket?</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Circuit Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_backend.html">Running on Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_compiler.html">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_noise.html">Noise and the Quantum Circuit Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_assertion.html">Assertion</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">More Documentation:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://cqcl.github.io/tket/pytket/api/">pytket</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cqcl.github.io/pytket-extensions/api/index.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/CQCL/pytket/tree/main/examples">Example notebooks</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/CQCL/tket" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/CQCL/tket/issues/new?title=Issue%20on%20page%20%2Fmanual_circuit.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/manual_circuit.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Circuit Construction</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-gates">Basic Gates</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#measurements">Measurements</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#barriers">Barriers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#registers-and-ids">Registers and IDs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composing-circuits">Composing Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#statevectors-and-unitaries">Statevectors and Unitaries</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analysing-circuits">Analysing Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#boxes">Boxes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-boxes">Circuit Boxes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boxes-for-unitary-synthesis">Boxes for Unitary Synthesis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#controlled-box-operations">Controlled Box Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pauli-exponential-boxes-and-phase-polynommials">Pauli Exponential Boxes and Phase Polynommials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiplexors-state-preperation-boxes-and-toffolibox">Multiplexors, State Preperation Boxes and <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#importing-exporting-circuits">Importing/Exporting Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#symbolic-circuits">Symbolic Circuits</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#symbolic-unitaries-and-states">Symbolic unitaries and states</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-topics">Advanced Topics</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#custom-parameterised-gates">Custom parameterised Gates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clifford-tableaux">Clifford Tableaux</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-and-conditional-operations">Classical and conditional operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-level-operations">Circuit-Level Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Implicit Qubit Permutations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modifying-operations-within-circuits">Modifying Operations Within Circuits</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="circuit-construction">
<h1>Circuit Construction<a class="headerlink" href="#circuit-construction" title="Permalink to this heading">#</a></h1>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class forms the unit of computation that we can send off to a quantum co-processor. Each instruction is to be performed in order, potentially parallelising when they use disjoint sets of (qu)bits. To capture this freedom of parallelisation, we treat the circuit as a Directed Acyclic Graph with a vertex for each instruction and directed edges following the paths of resources (e.g. qubits and bits) between them. This DAG representation describes the abstract circuit ignoring these trivial commutations/parallel instructions.</p>
<p>In general, we consider <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> instances to represent open circuits; that is, they can be used within arbitrary contexts, so any input state can be supplied and there is no assumption on how the output state should be used. In practice, when we send a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> off to be executed, it will be run with all qubits in the initial state <span class="math notranslate nohighlight">\(|0\rangle^{\otimes n}\)</span> and all bits set to <span class="math notranslate nohighlight">\(0\)</span>, then the classical outputs returned and the quantum state discarded.</p>
<p>Each circuit can be represented as a POVM on the combined quantum/classical state space by composing the representations assigned to each basic instruction. However, many use cases will live predominantly in the pure quantum space where the operations are simply unitaries acting on the quantum state. One practical distinction between these cases is the relevance of global phase: something that cannot be identified at the POVM level but has importance for pure states as it affects how we interpret the system and has an observable difference when the system is then coherently controlled. For example, an Rz gate and a U1 gate give equivalent effects on the quantum state but have a different global phase, meaning their unitaries <em>look</em> different, and a controlled-Rz is different from a controlled-U1. A <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> will track global phase to make working with pure quantum processes easier, though this becomes meaningless once measurements and other classical interaction are applied and has no impact on the instructions sent to a quantum device when we eventually run it.</p>
<p>Given the small scale and lack of dynamic quantum memories for both devices and simulations, we assume each qubit and bit is statically registered and hence each <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> has the same number of inputs as outputs. The set of data units (qubits and bits) used by the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> is hence going to be constant, so we can define it up-front when we construct one. We can also optionally give it a name for easy identification.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">trivial_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>        <span class="c1"># no qubits or bits</span>
<span class="n">quantum_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>       <span class="c1"># 4 qubits and no bits</span>
<span class="n">mixed_circ</span>   <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># 4 qubits and 2 bits</span>
<span class="n">named_circ</span>   <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;my_circ&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<section id="basic-gates">
<h2>Basic Gates<a class="headerlink" href="#basic-gates" title="Permalink to this heading">#</a></h2>
<p>The bulk of the interaction with a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> object will be in building up the sequence of instructions to be run. The simplest way to do this is by adding each instruction in execution order to the end of the circuit.</p>
<p>Basic quantum gates represent some unitary operation applied to some qubits. Adding them to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> just requires specifying which qubits you want to apply them to. For controlled-gates, the convention is to give the control qubit(s) first, followed by the target qubit(s).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="c1"># qubits are numbered 0-3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>           <span class="c1"># first apply an X gate to qubit 0</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>       <span class="c1"># and apply a CX gate with control qubit 1 and target qubit 3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>           <span class="c1"># then apply a Z gate to qubit 3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">()</span> <span class="c1"># show the commands of the built circuit</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[X q[0];, CX q[1], q[3];, Z q[3];]
</pre></div>
</div>
</div>
</div>
<p>For parameterised gates, such as rotations, the parameter is always given first. Because of the prevalence of rotations with angles given by fractions of <span class="math notranslate nohighlight">\(\pi\)</span> in practical quantum computing, the unit for all angular parameters is the half-turn (1 half-turn is equal to <span class="math notranslate nohighlight">\(\pi\)</span> radians).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1"># Rx of angle pi/2 radians on qubit 0</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CRz</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># Controlled-Rz of angle 0.3pi radians with</span>
                    <span class="c1">#   control qubit 1 and target qubit 0</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(0.5) q[0]; CRz(0.3) q[1], q[0]; ]
</pre></div>
</div>
</div>
</div>
<p>A large selection of common gates are available in this way, as listed in the API reference for the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class. However, for less commonly used gates, a wider variety is available using the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType</span></code> enum, which can be added using the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit.add_gate</span></code> method.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CnX</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="c1"># add controlled-X with control qubits 0, 1, 4 and target qubit 3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">XXPhase</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="c1"># add e^{-i (0.7 pi / 2) XX} on qubits 0 and 2</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">PhasedX</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="c1"># adds Rz(-0.5 pi); Rx(-0.1 pi); Rz(0.5 pi) on qubit 3</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[CnX q[0], q[1], q[4], q[3]; XXPhase(0.7) q[0], q[2]; PhasedX(3.9, 0.5) q[3]; ]
</pre></div>
</div>
</div>
</div>
<p>The API reference for the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType</span></code> class details all available operations that can exist in a circuit.</p>
<p>In the above example, we asked for a <code class="docutils literal notranslate"><span class="pre">PhasedX</span></code> with angles <code class="docutils literal notranslate"><span class="pre">[-0.1,</span> <span class="pre">0.5]</span></code>, but received <code class="docutils literal notranslate"><span class="pre">PhasedX(3.9,</span> <span class="pre">0.5)</span></code>. <code class="docutils literal notranslate"><span class="pre">pytket</span></code> will freely map angles into the range <span class="math notranslate nohighlight">\(\left[0, r\right)\)</span> for some range parameter <span class="math notranslate nohighlight">\(r\)</span> that depends on the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType</span></code>, preserving the unitary matrix (including global phase).</p>
</section>
<section id="measurements">
<h2>Measurements<a class="headerlink" href="#measurements" title="Permalink to this heading">#</a></h2>
<p>Measurements go a step further by interacting with both the quantum and classical data. The convention used in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> is that all measurements are non-destructive, single-qubit measurements in the <span class="math notranslate nohighlight">\(Z\)</span> basis; other forms of measurements can be constructed by combining these with other operations.</p>
<p>Adding a measurement works just like adding any other gate, where the first argument is the qubit to be measured and the second specifies the classical bit to store the result in.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Z-basis measurement on qubit 0, saving result in bit 0</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Measurement of IXXX, saving result in bit 1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[0] --&gt; c[0]; CX q[1], q[2]; CX q[1], q[3]; H q[1]; Measure q[1] --&gt; c[1]; ]
</pre></div>
</div>
</div>
</div>
<p>Because the classical bits are treated as statically assigned locations, writing to the same bit multiple times will overwrite the previous value.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># measure the first measurement</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># overwrites the first result with a new measurement</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[0] --&gt; c[0]; CX q[0], q[1]; Measure q[1] --&gt; c[0]; ]
</pre></div>
</div>
</div>
</div>
<p>Depending on where we plan on running our circuits, the backend or simulator might have different requirements on the structure of measurements in the circuits. For example, statevector simulators will only work deterministically for pure-quantum circuits, so will fail if any measures are present at all. More crucially, near-term quantum hardware almost always requires all measurements to occur in a single parallel layer at the end of the circuit (i.e. we cannot measure a qubit in the middle of the circuit).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ0</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># all measurements at end</span>
<span class="n">circ0</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ0</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ0</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">circ1</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># this is DAG-equivalent to circ1, so is still ok</span>
<span class="n">circ1</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ1</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ1</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">circ2</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="c1"># reuses qubit 0 after measuring, so this may be rejected by a device</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ2</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">circ3</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># overwriting the classical value means we have to measure qubit 0</span>
    <span class="c1"># before qubit 1; they won&#39;t occur simultaneously so this may be rejected</span>
<span class="n">circ3</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ3</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[0] --&gt; c[0]; Measure q[1] --&gt; c[0]; ]
</pre></div>
</div>
</div>
</div>
<p>The simplest way to guarantee this is to finish the circuit by measuring all qubits. There is a short-hand function <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.measure_all()</span></code> to make this easier.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="c1"># measure qubit 0 in Z basis and 1 in X basis</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="c1"># measure_all() adds bits if they are not already defined, so equivalently</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[0] --&gt; c[0]; H q[1]; Measure q[1] --&gt; c[1]; ]
</pre></div>
</div>
</div>
</div>
<p>On devices where mid-circuit measurements are available, they may be highly noisy and not apply just a basic projector on the quantum state. We can view these as “effectively destructive” measurements, where the qubit still exists but is in a noisy state. In this case, it is recommended to actively reset a qubit after measurement if it is intended to be reused.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># Actively reset state to |0&gt;</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">Reset</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Conditionally flip state to |1&gt; to reflect measurement result</span>
<span class="n">circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">condition_bits</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">condition_value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Use the qubit as if the measurement was non-destructive</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[0] --&gt; c[0]; Reset q[0]; IF ([c[0]] == 1) THEN X q[0]; CX q[0], q[1]; ]
</pre></div>
</div>
</div>
</div>
</section>
<section id="barriers">
<h2>Barriers<a class="headerlink" href="#barriers" title="Permalink to this heading">#</a></h2>
<p>The concept of barriers comes from low-level classical programming. They exist as instructions but perform no active operation. Instead, their function is twofold:</p>
<ul class="simple">
<li><p>At compile-time, prevent the compiler from reordering operations around the barrier.</p></li>
<li><p>At runtime, ensure that all operations before the barrier must have finished before any operations after the barrier start.</p></li>
</ul>
<p>The intention is the same for <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s. Inserting barriers can be used to segment the program to easily spot how it is modified during compilation, and some quantum hardware uses barriers as the primary method of embedding timing information.</p>
<p>Adding a barrier to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> is done using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.add_barrier()</span></code> method. In general, a barrier is placed on some subset of the (qu)bits to impose these ordering restrictions on those (qu)bits specifically (i.e. we don’t care about reorders on the other (qu)bits).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_barrier</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1"># add a barrier on all qubits and bits</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[H q[0]; CX q[1], q[2]; Barrier q[0], q[1], q[2], q[3], c[0], c[1]; Measure q[0] --&gt; c[0]; Measure q[2] --&gt; c[1]; ]
</pre></div>
</div>
</div>
</div>
</section>
<section id="registers-and-ids">
<h2>Registers and IDs<a class="headerlink" href="#registers-and-ids" title="Permalink to this heading">#</a></h2>
<p>Using integer values to refer to each of our qubits and bits works fine for small-scale experiments, but when building up larger and more complicated programs, it is much easier to manage if we are able to name the resources to attach semantic meaning to them and group them into related collections. <code class="docutils literal notranslate"><span class="pre">pytket</span></code> enables this by supporting registers and named IDs.</p>
<p>Each unit resource is associated with a <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> (typically the subclasses <code class="xref py py-class docutils literal notranslate"><span class="pre">Qubit</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Bit</span></code>), which gives a name and some (<span class="math notranslate nohighlight">\(n\)</span>-dimensional) index. A (quantum/classical) register is hence some collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> s with the same name, dimension of index, and type of associated resource. These identifiers are not necessarily tied to a specific <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> and can be reused between many of them.</p>
<p>Named resources can be added to <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s individually, or by declaring a 1-dimensional register. Any of the methods for adding gates can then use these IDs.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">qreg</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;reg&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>    <span class="c1"># add a qubit register</span>

<span class="n">anc</span> <span class="o">=</span> <span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;ancilla&quot;</span><span class="p">)</span>                  <span class="c1"># add a named qubit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">anc</span><span class="p">)</span>

<span class="n">par</span> <span class="o">=</span> <span class="n">Bit</span><span class="p">(</span><span class="s2">&quot;parity&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>             <span class="c1"># add a named bit with a 2D index</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_bit</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>

<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">anc</span><span class="p">)</span>                   <span class="c1"># add gates in terms of IDs</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">anc</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="n">anc</span><span class="p">,</span> <span class="n">par</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[CX reg[0], ancilla; CX reg[1], ancilla; Measure ancilla --&gt; parity[0, 0]; ]
</pre></div>
</div>
</div>
</div>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> can be inspected to identify what qubits and bits it contains.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">bits</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[a[0], a[1], a[2], a[3], b]
[z[0], z[1], z[2]]
</pre></div>
</div>
</div>
</div>
<p>To help encourage consistency of identifiers, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> will reject a new (qu)bit or register if it disagrees with existing IDs with the same name; that is, it refers to a different resource type (qubit vs bit), the index has a different dimension, or some resource already exists with the exact same ID in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>. Identifiers with the same register name do not have to have contiguous indices (many devices require non-contiguous indices because qubits may be taken offline over the lifetime of the device).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># set up a circuit with qubit a[0]</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="c1"># rejected because &quot;a&quot; is already a qubit register</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_bit</span><span class="p">(</span><span class="n">Bit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">RuntimeError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span> <span class="n">line</span> <span class="mi">8</span>
<span class="g g-Whitespace">      </span><span class="mi">5</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="g g-Whitespace">      </span><span class="mi">7</span> <span class="c1"># rejected because &quot;a&quot; is already a qubit register</span>
<span class="ne">----&gt; </span><span class="mi">8</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_bit</span><span class="p">(</span><span class="n">Bit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="ne">RuntimeError</span>: Cannot add bit with ID &quot;a[1]&quot; as register is not compatible
</pre></div>
</div>
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># rejected because &quot;a&quot; is already a 1D register</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">RuntimeError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">14</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1"># rejected because &quot;a&quot; is already a 1D register</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">))</span>

<span class="ne">RuntimeError</span>: Cannot add qubit with ID &quot;a[1, 2]&quot; as register is not compatible
</pre></div>
</div>
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># rejected because a[0] is already in the circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">RuntimeError</span><span class="g g-Whitespace">                              </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span> <span class="n">line</span> <span class="mi">2</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="c1"># rejected because a[0] is already in the circuit</span>
<span class="ne">----&gt; </span><span class="mi">2</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="ne">RuntimeError</span>: A unit with ID &quot;a[0]&quot; already exists
</pre></div>
</div>
</div>
</div>
<p>The basic integer identifiers are actually a special case, referring to the default qubit (<code class="docutils literal notranslate"><span class="pre">q[i]</span></code>) and bit (<code class="docutils literal notranslate"><span class="pre">c[i]</span></code>) registers. We can create the <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> using the nameless <code class="xref py py-class docutils literal notranslate"><span class="pre">Qubit</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Bit</span></code> constructors.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>    <span class="c1"># same as circ.CX(0, 1)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Measure</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">Bit</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># same as circ.Measure(2, 0)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Measure q[2] --&gt; c[0]; CX q[0], q[1]; ]
</pre></div>
</div>
</div>
</div>
<p>In some circumstances, it may be useful to rename the resources in the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>. Given a partial map on <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> s, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.rename_units()</span></code> will change the association of IDs to resources (as long as the final labelling would still have consistent types for all registers). Any unspecified IDs will be preserved.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qubit</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="nb">map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
    <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="n">Qubit</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">Bit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">:</span> <span class="n">Bit</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="p">}</span>
<span class="n">circ</span><span class="o">.</span><span class="n">rename_units</span><span class="p">(</span><span class="nb">map</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">bits</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[a[0], q[0], q[3]]
[c[1], z[0, 1]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="composing-circuits">
<h2>Composing Circuits<a class="headerlink" href="#composing-circuits" title="Permalink to this heading">#</a></h2>
<p>Because <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s are defined to have open inputs and outputs, it is perfectly natural to compose them by unifying the outputs of one with the inputs of another. Appending one <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> to the end of another matches the inputs and outputs with the same <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">,</span> <span class="n">Bit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">measures</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">measures</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">measures</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">measures</span><span class="p">)</span>
<span class="n">circ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[CX q[0], q[1]; Rz(0.3) q[1]; CX q[0], q[1]; Measure q[0] --&gt; c[0]; H q[1]; Measure q[1] --&gt; c[1]; ]
</pre></div>
</div>
</div>
</div>
<p>If one <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> lacks some unit present in the other, then we treat it as if it is an identity on that unit. In the extreme case where the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s are defined with disjoint sets of <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> s, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.append()</span></code> method will compose them in parallel.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="nb">next</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">b</span> <span class="o">=</span> <span class="nb">next</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">next</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">next</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">next</span><span class="p">)</span>
<span class="n">circ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(0.2) a[0]; Z b[0]; CX a[0], a[1]; CZ b[1], b[0]; ]
</pre></div>
</div>
</div>
</div>
<p>To change which units get unified, we could use <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.rename_units()</span></code> as seen before, but in the case where we just want to append a subcircuit like a gate, we can do this with <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.add_circuit()</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="nb">next</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">next</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">next</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="nb">next</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

<span class="c1"># This is equivalent to:</span>
<span class="c1"># temp = next.copy()</span>
<span class="c1"># temp.rename_units({Qubit(0) : a[1], Qubit(1) : a[0]})</span>
<span class="c1"># circ.append(temp)</span>

<span class="n">circ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(0.2) a[0]; CX a[0], a[1]; Z a[1]; CZ a[0], a[1]; ]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This requires the subcircuit to be defined only over the default registers so that the list of arguments given to <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.add_circuit()</span></code> can easily be mapped.</p>
</div>
</section>
<section id="statevectors-and-unitaries">
<h2>Statevectors and Unitaries<a class="headerlink" href="#statevectors-and-unitaries" title="Permalink to this heading">#</a></h2>
<p>When working with quantum circuits we may want access to the quantum state prepared by our circuit. This can be helpful if we want to check whether our circuit construction is correct. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.get_statevector()</span></code> method will produce the statevector of our system after the circuit is applied. Here it is assumed that all the qubits are initialised in the <span class="math notranslate nohighlight">\(|0\rangle^{\otimes n}\)</span> state.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([0.70710678+0.j, 0.        +0.j, 0.        +0.j, 0.70710678+0.j])
</pre></div>
</div>
</div>
</div>
<p>In addition <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.get_unitary()</span></code> can be used to numerically calculate the unitary matrix that will be applied by the circuit.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">get_unitary</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([[ 0.5+0.j,  0.5+0.j,  0.5+0.j,  0.5+0.j],
       [ 0.5+0.j, -0.5+0.j,  0.5+0.j, -0.5+0.j],
       [ 0.5+0.j, -0.5+0.j, -0.5+0.j,  0.5+0.j],
       [ 0.5+0.j,  0.5+0.j, -0.5+0.j, -0.5+0.j]])
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The unitary matrix of a quantum circuit is of dimension <span class="math notranslate nohighlight">\((2^n \times 2^n)\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is the number of qubits. The statevector will be a column vector with <span class="math notranslate nohighlight">\(2^n\)</span> entries . Due to this exponential scaling it will in general be very inefficient to compute the unitary (or statevector) of a circuit. These functions are intended to be used for sanity checks and spotting mistakes in small circuits.</p>
</div>
</section>
<section id="analysing-circuits">
<h2>Analysing Circuits<a class="headerlink" href="#analysing-circuits" title="Permalink to this heading">#</a></h2>
<p>After creating a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>, we will typically want to inspect what we have constructed to ensure that it agrees with the design we planned. The most basic form of this is to just get the object to return the sequence of operations back to us. Iterating through the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> object will give back the operations as <code class="xref py py-class docutils literal notranslate"><span class="pre">Command</span></code> s (specifying the operations performed and what (qu)bits they are performed on).</p>
<p>Because the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class identifies circuits up to DAG equivalence, the sequence will be some topological sort of the DAG, but not necessarily identical to the order the operations were added to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">com</span> <span class="ow">in</span> <span class="n">circ</span><span class="p">:</span> <span class="c1"># equivalently, circ.get_commands()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">com</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">com</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
    <span class="c1"># NOTE: com is not a reference to something inside circ; this cannot be used to modify the circuit</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>CX OpType.CX [q[0], q[1]]
Rx(0.3) OpType.Rx [q[0]]
CZ OpType.CZ [q[1], q[2]]
X OpType.X [q[1]]
</pre></div>
</div>
</div>
</div>
<p>If you are working in a Jupyter environment, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> can be rendered using html for inline display.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.circuit.display</span> <span class="kn">import</span> <span class="n">render_circuit_jupyter</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span> <span class="c1"># Render interactive circuit diagram</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-b3d607ed-035c-4e40-84e9-026dc6e41a87&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.3&#34;], &#34;type&#34;: &#34;Rx&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;b3d607ed-035c-4e40-84e9-026dc6e41a87&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The pytket circuit renderer can represent circuits in the standard circuit model or in the ZX representation. Other interactive features include adjustable zoom, circuit wrapping and image export.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pytket</span></code> also features methods to visualise the underlying circuit DAG graphically for easier visual inspection.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">Graph</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span><span class="o">.</span><span class="n">get_DAG</span><span class="p">()</span>   <span class="c1"># Displays in interactive python notebooks</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_circuit_24_0.svg" src="_images/manual_circuit_24_0.svg" /></div>
</div>
<p>The visualisation tool can also describe the interaction graph of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> consisting of only one- and two-qubit gates – that is, the graph of which qubits will share a two-qubit gate at some point during execution.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The visualisations above are shown in ipython notebook cells. When working with a normal python script one can view rendered circuits in the browser with the <code class="xref py py-meth docutils literal notranslate"><span class="pre">view_browser()</span></code> function from the display module.</p>
<p>There are also the methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.save_DAG()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Graph.view_DAG()</span></code> for saving and visualising the circuit DAG.</p>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">Graph</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ZZPhase</span><span class="p">(</span><span class="mf">0.63</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">CY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span><span class="o">.</span><span class="n">get_qubit_graph</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_circuit_25_0.svg" src="_images/manual_circuit_25_0.svg" /></div>
</div>
<p>The full instruction sequence may often be too much detail for a lot of needs, especially for large circuits. Common circuit metrics like gate count and depth are used to approximate the difficulty of running it on a device, providing some basic tools to help distinguish different implementations of a given algorithm.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total gate count =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_gates</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Circuit depth =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">depth</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Total gate count = 4
Circuit depth = 3
</pre></div>
</div>
</div>
</div>
<p>As characteristics of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> go, these are pretty basic. In terms of approximating the noise level, they fail heavily from weighting all gates evenly when, in fact, some will be much harder to implement than others. For example, in the NISQ era, we find that most technologies provide good single-qubit gate times and fidelities, with two-qubit gates being much slower and noisier <a class="reference internal" href="manual_intro.html#arut2019" id="id1"><span>[Arut2019]</span></a>. On the other hand, looking forward to the fault-tolerant regime we will expect Clifford gates to be very cheap but the magic <span class="math notranslate nohighlight">\(T\)</span> gates to require expensive distillation procedures <a class="reference internal" href="#brav2005" id="id2"><span>[Brav2005]</span></a> <a class="reference internal" href="#brav2012" id="id3"><span>[Brav2012]</span></a>.</p>
<p>We can use the <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType</span></code> enum class to look for the number of gates of a particular type. Additionally, the methods <code class="xref py py-meth docutils literal notranslate"><span class="pre">n_1qb_gates()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">n_2qb_gates()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">n_nqb_gates()</span></code> can be used to count the number of gates in terms of how many qubits they act upon irrespective of type.</p>
<p>We also define <span class="math notranslate nohighlight">\(G\)</span>-depth (for a subset of gate types <span class="math notranslate nohighlight">\(G\)</span>) as the minimum number of layers of gates in <span class="math notranslate nohighlight">\(G\)</span> required to run the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>, allowing for topological reorderings. Specific cases of this like <span class="math notranslate nohighlight">\(T\)</span>-depth and <span class="math notranslate nohighlight">\(CX\)</span>-depth are common to the literature on circuit simplification <a class="reference internal" href="#amy2014" id="id4"><span>[Amy2014]</span></a> <a class="reference internal" href="#meij2020" id="id5"><span>[Meij2020]</span></a>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>
<span class="kn">from</span> <span class="nn">pytket.circuit.display</span> <span class="kn">import</span> <span class="n">render_circuit_jupyter</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CnRy</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span> <span class="c1"># draw circuit diagram</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;T gate count =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_gates_of_type</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#1qb gates =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_1qb_gates</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#2qb gates =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_2qb_gates</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;#3qb gates =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">n_nqb_gates</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># count the single CnRy gate (n=3)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;T gate depth =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">depth_by_type</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;2qb gate depth =&quot;</span><span class="p">,</span> <span class="n">circ</span><span class="o">.</span><span class="n">depth_by_type</span><span class="p">({</span><span class="n">OpType</span><span class="o">.</span><span class="n">CX</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">CZ</span><span class="p">}))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-75c6e0e6-da6e-414c-82b0-66658dc7342a&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;T&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;n_qb&#34;: 3, &#34;params&#34;: [&#34;0.6&#34;], &#34;type&#34;: &#34;CnRy&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;T&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;T&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;75c6e0e6-da6e-414c-82b0-66658dc7342a&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div><div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>T gate count = 3
#1qb gates = 3
#2qb gates = 4
#3qb gates = 1
T gate depth = 3
2qb gate depth = 4
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Each of these metrics will analyse the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> “as is”, so they will consider each Box as a single unit rather than breaking it down into basic gates, nor will they perform any non-trivial gate commutations (those that don’t just follow by deformation of the DAG) or gate decompositions (e.g. recognising that a <span class="math notranslate nohighlight">\(CZ\)</span> gate would contribute 1 to <span class="math notranslate nohighlight">\(CX\)</span>-count in practice).</p>
</div>
</section>
<section id="boxes">
<h2>Boxes<a class="headerlink" href="#boxes" title="Permalink to this heading">#</a></h2>
<p>Working with individual basic gates is sufficient for implementing arbitrary circuits, but that doesn’t mean it is the most convenient option. It is generally far easier to argue the correctness of a circuit’s design when it is constructed using higher-level constructions. In <code class="docutils literal notranslate"><span class="pre">pytket</span></code>, the concept of a “Box” is to abstract away such complex structures as black-boxes within larger circuits.</p>
<section id="circuit-boxes">
<h3>Circuit Boxes<a class="headerlink" href="#circuit-boxes" title="Permalink to this heading">#</a></h3>
<p>The simplest example of this is a <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code>, which wraps up another <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> defined elsewhere into a single black-box. The difference between adding a <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> and just appending the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> is that the <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> allows us to wrap up and abstract away the internal structure of the subcircuit we are adding so it appears as if it were a single gate when we view the main <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>.</p>
<p>Let’s first build a basic quantum circuit which implements a simplified version of a Grover oracle and then add
it to another circuit as part of a larger algorithm.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>
<span class="kn">from</span> <span class="nn">pytket.circuit.display</span> <span class="kn">import</span> <span class="n">render_circuit_jupyter</span>

<span class="n">oracle_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Oracle&quot;</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CnZ</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">oracle_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">oracle_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-b29d05ac-303e-4065-8e9a-7ebba38b6dee&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;n_qb&#34;: 3, &#34;type&#34;: &#34;CnZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;name&#34;: &#34;Oracle&#34;, &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;b29d05ac-303e-4065-8e9a-7ebba38b6dee&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>Now that we’ve built our circuit we can wrap it up in a <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> and add it to a another circuit as a subroutine.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">CircBox</span>

<span class="n">oracle_box</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">oracle_circ</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">oracle_box</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-90bda285-7a77-4a39-bca9-ac336e5cd080&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;box&#34;: {&#34;circuit&#34;: {&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;n_qb&#34;: 3, &#34;type&#34;: &#34;CnZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;name&#34;: &#34;Oracle&#34;, &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}, &#34;id&#34;: &#34;65ae290a-394d-47a9-80ea-0b7302885d0b&#34;, &#34;type&#34;: &#34;CircBox&#34;}, &#34;type&#34;: &#34;CircBox&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;90bda285-7a77-4a39-bca9-ac336e5cd080&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>See how the name of the circuit appears in the rendered circuit diagram. Clicking on the box will show the underlying circuit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Despite the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class having methods for adding each type of box, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.add_gate()</span></code> is sufficiently general to append any pytket OpType to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>.</p>
</div>
</section>
<section id="boxes-for-unitary-synthesis">
<h3>Boxes for Unitary Synthesis<a class="headerlink" href="#boxes-for-unitary-synthesis" title="Permalink to this heading">#</a></h3>
<p>It is possible to specify small unitaries from <code class="docutils literal notranslate"><span class="pre">numpy</span></code> arrays and embed them directly into circuits as boxes, which can then be synthesised into gate sequences during compilation.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Unitary1qBox</span><span class="p">,</span> <span class="n">Unitary2qBox</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">],</span>
                 <span class="p">[(</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">]])</span>
<span class="n">u1box</span> <span class="o">=</span> <span class="n">Unitary1qBox</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

<span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                 <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="n">u2box</span> <span class="o">=</span> <span class="n">Unitary2qBox</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_unitary1qbox</span><span class="p">(</span><span class="n">u1box</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_unitary2qbox</span><span class="p">(</span><span class="n">u2box</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_unitary1qbox</span><span class="p">(</span><span class="n">u1box</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_unitary2qbox</span><span class="p">(</span><span class="n">u2box</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Unitary1qBox q[0]; Unitary2qBox q[1], q[2]; Unitary2qBox q[1], q[0]; Unitary1qBox q[2]; ]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For performance reasons pytket currently only supports unitary synthesis up to three qubits. Three-qubit synthesis can be accomplished with <code class="xref py py-class docutils literal notranslate"><span class="pre">Unitary3qBox</span></code> using a similar syntax.</p>
</div>
<p>Also in this category of synthesis boxes is <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalBox</span></code>. This allows synthesis of circuits for diagonal unitaries.
This box can be constructed by passing in a <span class="math notranslate nohighlight">\((1 \times 2^n)\)</span> numpy array representing the diagonal entries of the desired unitary matrix.</p>
</section>
<section id="controlled-box-operations">
<h3>Controlled Box Operations<a class="headerlink" href="#controlled-box-operations" title="Permalink to this heading">#</a></h3>
<p>If our subcircuit is a pure quantum circuit (i.e. it corresponds to a unitary operation), we can construct the controlled version that is applied coherently according to some set of control qubits. If all control qubits are in the <span class="math notranslate nohighlight">\(|1\rangle\)</span> state, then the unitary is applied to the target system, otherwise it acts as an identity.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">CircBox</span><span class="p">,</span> <span class="n">QControlBox</span>

<span class="n">sub</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sub</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">sub_box</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span>

<span class="c1"># Define the controlled operation with 2 control qubits</span>
<span class="n">cont</span> <span class="o">=</span> <span class="n">QControlBox</span><span class="p">(</span><span class="n">sub_box</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">sub_box</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="mf">0.8</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add to circuit with controls q[0], q[1], and targets q[2], q[3]</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_qcontrolbox</span><span class="p">(</span><span class="n">cont</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[Ry(0.3) q[0]; Ry(0.8) q[1]; CircBox q[2], q[3]; qif (q[0], q[1]) CircBox q[2], q[3]; ]
</pre></div>
</div>
</div>
</div>
<p>As well as creating controlled boxes, we can create a controlled version of an arbitrary <code class="xref py py-class docutils literal notranslate"><span class="pre">Op</span></code> as follows.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Op</span><span class="p">,</span> <span class="n">OpType</span><span class="p">,</span> <span class="n">QControlBox</span>

<span class="n">op</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">S</span><span class="p">)</span>
<span class="n">ccs</span> <span class="o">=</span> <span class="n">QControlBox</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>In addition, we can construct a <code class="xref py py-class docutils literal notranslate"><span class="pre">QControlBox</span></code> from any other pure quantum box type in pytket.
For example, we can construct a multicontrolled <span class="math notranslate nohighlight">\(\sqrt{Y}\)</span> operation as by first synthesising the base unitary with <code class="xref py py-class docutils literal notranslate"><span class="pre">Unitary1qBox</span></code> and then constructing a <code class="xref py py-class docutils literal notranslate"><span class="pre">QControlBox</span></code> from the box implementing <span class="math notranslate nohighlight">\(\sqrt{Y}\)</span>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Unitary1qBox</span><span class="p">,</span> <span class="n">QControlBox</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Unitary for sqrt(Y)</span>
<span class="n">sqrt_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
                     <span class="p">[</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span>

<span class="n">sqrt_y_box</span> <span class="o">=</span> <span class="n">Unitary1qBox</span><span class="p">(</span><span class="n">sqrt_y</span><span class="p">)</span>
<span class="n">c2_root_y</span> <span class="o">=</span> <span class="n">QControlBox</span><span class="p">(</span><span class="n">sqrt_y_box</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Whilst adding a control qubit is asymptotically efficient, the gate overhead is significant and can be hard to synthesise optimally, so using these constructions in a NISQ context should be done with caution.</p>
</div>
</section>
<section id="pauli-exponential-boxes-and-phase-polynommials">
<h3>Pauli Exponential Boxes and Phase Polynommials<a class="headerlink" href="#pauli-exponential-boxes-and-phase-polynommials" title="Permalink to this heading">#</a></h3>
<p>Another notable construct that is common to many algorithms and high-level circuit descriptions is the exponential of a Pauli tensor:</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
e^{-i \frac{\pi}{2} \theta P}\,, \quad P \in \{I, X, Y, Z\}^{\otimes n}
\end{equation}\]</div>
<p>These occur very naturally in Trotterising evolution operators and native device operations.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">PauliExpBox</span>
<span class="kn">from</span> <span class="nn">pytket.pauli</span> <span class="kn">import</span> <span class="n">Pauli</span>

<span class="c1"># Construct PauliExpBox(es) with a list of Paulis followed by the phase</span>
<span class="n">xyyz</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">],</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">zzyx</span> <span class="o">=</span> <span class="n">PauliExpBox</span><span class="p">([</span><span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">Pauli</span><span class="o">.</span><span class="n">X</span><span class="p">],</span> <span class="mf">0.7</span><span class="p">)</span>

<span class="n">pauli_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

<span class="n">pauli_circ</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">xyyz</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">pauli_circ</span><span class="o">.</span><span class="n">add_pauliexpbox</span><span class="p">(</span><span class="n">zzyx</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[PauliExpBox q[0], q[1], q[2], q[3]; PauliExpBox q[1], q[2], q[3], q[4]; ]
</pre></div>
</div>
</div>
</div>
<p>To understand what happens inside a <code class="xref py py-class docutils literal notranslate"><span class="pre">PauliExpBox</span></code> let’s take a look at the underlying circuit for <span class="math notranslate nohighlight">\(e^{-i \frac{\pi}{2}\theta ZZYX}\)</span></p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">zzyx</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-d42f9afb-c72b-49aa-8e9a-645bf1f210c7&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;V&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.7&#34;], &#34;type&#34;: &#34;Rz&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;Vdg&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]], [[&#34;q&#34;, [3]], [&#34;q&#34;, [3]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]], [&#34;q&#34;, [3]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;d42f9afb-c72b-49aa-8e9a-645bf1f210c7&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>All Pauli exponentials of the form above can be implemented in terms of a single Rz(<span class="math notranslate nohighlight">\(\theta\)</span>) rotation and a symmetric chain of CX gates on either side together with some single qubit basis rotations. This class of circuit is called a Pauli gadget. The subset of these circuits corresponding to “Z only” Pauli strings are referred to as phase gadgets.</p>
<p>We see that the Pauli exponential <span class="math notranslate nohighlight">\(e^{i\frac{\pi}{2} \theta \text{ZZYX}}\)</span> has basis rotations on the third and fourth qubit. The V and Vdg gates rotate from the default Z basis to the Y basis and the Hadamard gate serves to change to the X basis.</p>
<p>These Pauli gadget circuits have interesting algebraic properties which are useful for circuit optimisation. For instance Pauli gadgets are unitarily invariant under the permutation of their qubits. For further discussion see the research publication on phase gadget synthesis <a class="reference internal" href="#cowt2020" id="id6"><span>[Cowt2020]</span></a>. Ideas from this paper are implemented in TKET as the <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.OptimisePhaseGadgets">OptimisePhaseGadgets</a> and <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.PauliSimp">PauliSimp</a> optimisation passes.</p>
<p>Now we move on to discuss another class of quantum circuits known as phase polynomials. Phase polynomial circuits are a special type of circuits that use the {CX, Rz} gateset.</p>
<p>A phase polynomial <span class="math notranslate nohighlight">\(p(x)\)</span> is defined as a weighted sum of Boolean linear functions <span class="math notranslate nohighlight">\(f_i(x)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
p(x) = \sum_{i=1}^{2^n} \theta_i f_i(x)
\end{equation}\]</div>
<p>A phase polynomial circuit <span class="math notranslate nohighlight">\(C\)</span> has the following action on computational basis states <span class="math notranslate nohighlight">\(|x\rangle\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
C: |x\rangle \longmapsto e^{2\pi i p(x)}|g(x)\rangle
\end{equation}\]</div>
<p>Such a phase polynomial circuit can be synthesisied in pytket using the <code class="xref py py-class docutils literal notranslate"><span class="pre">PhasePolyBox</span></code>. A <code class="xref py py-class docutils literal notranslate"><span class="pre">PhasePolyBox</span></code> is constructed using the number of qubits, the qubit indices and a dictionary indicating whether or not a phase should be applied to specific qubits.</p>
<p>Finally a <code class="docutils literal notranslate"><span class="pre">linear_transfromation</span></code> parameter needs to be specified:  this is a matrix encoding the linear permutation between the bitstrings <span class="math notranslate nohighlight">\(|x\rangle\)</span> and <span class="math notranslate nohighlight">\(|g(x)\rangle\)</span> in the equation above.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">PhasePolyBox</span>

<span class="n">phase_poly_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="n">qubit_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">):</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="mi">2</span><span class="p">}</span>

<span class="n">phase_polynomial</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="mf">0.333</span><span class="p">,</span>
    <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span> <span class="mf">1.05</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">n_qb</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">linear_transformation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="n">p_box</span> <span class="o">=</span> <span class="n">PhasePolyBox</span><span class="p">(</span><span class="n">n_qb</span><span class="p">,</span> <span class="n">qubit_indices</span><span class="p">,</span> <span class="n">phase_polynomial</span><span class="p">,</span> <span class="n">linear_transformation</span><span class="p">)</span>

<span class="n">phase_poly_circ</span><span class="o">.</span><span class="n">add_phasepolybox</span><span class="p">(</span><span class="n">p_box</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">p_box</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-ac6f4d12-c3bb-4a49-8d8b-a973c31a5169&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;params&#34;: [&#34;1.05&#34;], &#34;type&#34;: &#34;Rz&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.05&#34;], &#34;type&#34;: &#34;Rz&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.333&#34;], &#34;type&#34;: &#34;Rz&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;ac6f4d12-c3bb-4a49-8d8b-a973c31a5169&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
</section>
<section id="multiplexors-state-preperation-boxes-and-toffolibox">
<h3>Multiplexors, State Preperation Boxes and <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code><a class="headerlink" href="#multiplexors-state-preperation-boxes-and-toffolibox" title="Permalink to this heading">#</a></h3>
<p>In the context of quantum circuits a multiplexor is type of generalised multicontrolled gate. Multiplexors grant us the flexibility to specify different operations on target qubits for different control states.
To create a multiplexor we simply construct a dictionary where the keys are the state of the control qubits and the values represent the operation performed on the target.</p>
<p>Lets implement a multiplexor with the following logic. Here we treat the first two qubits as controls and the third qubit as the target.</p>
<dl class="simple">
<dt>if control qubits in <span class="math notranslate nohighlight">\(|00\rangle\)</span>:</dt><dd><p>do Rz(0.3) on the third qubit</p>
</dd>
<dt>else if control qubits in <span class="math notranslate nohighlight">\(|11\rangle\)</span>:</dt><dd><p>do H on the third qubit</p>
</dd>
<dt>else:</dt><dd><p>do identity (i.e. do nothing)</p>
</dd>
</dl>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Op</span><span class="p">,</span> <span class="n">MultiplexorBox</span>

<span class="c1"># Define both gates as an Op</span>
<span class="n">rz_op</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">Rz</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="n">h_op</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

<span class="n">op_map</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">rz_op</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">h_op</span><span class="p">}</span>
<span class="n">multiplexor</span> <span class="o">=</span> <span class="n">MultiplexorBox</span><span class="p">(</span><span class="n">op_map</span><span class="p">)</span>

<span class="n">multi_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">multi_circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Put both control qubits in the state |1&gt;</span>
<span class="n">multi_circ</span><span class="o">.</span><span class="n">add_multiplexor</span><span class="p">(</span><span class="n">multiplexor</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>

<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">multi_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-7aa8bcaa-16d1-4f34-8886-bd3ce3b93069&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;X&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;b6590c04-6c52-4725-bcb4-5e690be67fb5&#34;, &#34;op_map&#34;: [[[false, false], {&#34;params&#34;: [&#34;0.3&#34;], &#34;type&#34;: &#34;Rz&#34;}], [[true, true], {&#34;type&#34;: &#34;H&#34;}]], &#34;type&#34;: &#34;MultiplexorBox&#34;}, &#34;type&#34;: &#34;MultiplexorBox&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;7aa8bcaa-16d1-4f34-8886-bd3ce3b93069&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>Notice how in the example above the control qubits are both in the <span class="math notranslate nohighlight">\(|1\rangle\)</span> state and so the multiplexor applies the Hadamard operation to the third qubit. If we calculate our statevector we see that the third qubit is in the
<span class="math notranslate nohighlight">\(|+\rangle = H|0\rangle\)</span> state.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assume all qubits initialised to |0&gt; here</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Statevector =&quot;</span><span class="p">,</span> <span class="n">multi_circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">())</span>  <span class="c1"># amplitudes of |+&gt; approx 0.707...</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Statevector = [0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j
 0.        +0.j 0.        +0.j 0.70710678+0.j 0.70710678+0.j]
</pre></div>
</div>
</div>
</div>
<p>In addition to the general <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiplexor</span></code> pytket has several other type of multiplexor box operations available.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Multiplexor</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiplexorBox</span></code></p></td>
<td><p>The most general type of multiplexor (see above)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiplexedRotationBox</span></code></p></td>
<td><p>Multiplexor where the operation applied to the
target is a rotation gate about a single axis</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiplexedU2Box</span></code></p></td>
<td><p>Multiplexor for unifromly controlled single
qubit gates (U(2) operations)</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiplexedTensoredU2Box</span></code></p></td>
<td><p>Multiplexor where the operation applied to the
target is a tensor product of single qubit gates</p></td>
</tr>
</tbody>
</table>
<p>One place where multiplexor operations are useful is in state preparation algorithms.</p>
<p>TKET supports the preparation of arbitrary quantum states via the <code class="xref py py-class docutils literal notranslate"><span class="pre">StatePreparationBox</span></code>. This box takes a  <span class="math notranslate nohighlight">\((1\times 2^n)\)</span> numpy array representing the <span class="math notranslate nohighlight">\(n\)</span> qubit statevector where the entries represent the amplitudes of the quantum state.</p>
<p>Given the vector of amplitudes TKET will construct a box containing a sequence of multiplexors using the method outlined in <a class="reference internal" href="#shen2004" id="id7"><span>[Shen2004]</span></a>.</p>
<p>To demonstrate <code class="xref py py-class docutils literal notranslate"><span class="pre">StatePreparationBox</span></code> let’s use it to prepare the Werner state <span class="math notranslate nohighlight">\(|W\rangle\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{equation}
|W\rangle = \frac{1}{\sqrt{3}} \big(|001\rangle + |010\rangle + |100\rangle \big)
\end{equation}\]</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">StatePreparationBox</span>

<span class="n">werner_state</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="n">werner_state_box</span> <span class="o">=</span> <span class="n">StatePreparationBox</span><span class="p">(</span><span class="n">werner_state</span><span class="p">)</span>

<span class="n">state_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_circ</span><span class="o">.</span><span class="n">add_state_preparation_box</span><span class="p">(</span><span class="n">werner_state_box</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[StatePreparationBox q[0], q[1], q[2]; ]
</pre></div>
</div>
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Verify state preperation</span>
<span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># 1/sqrt(3) approx 0.577</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([-0.   ,  0.577,  0.577,  0.   ,  0.577,  0.   ,  0.   ,  0.   ])
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Generic state preperation circuits can be very complex with the gatecount and depth increasing rapidly with the size of the state. In the special case where the desired state has only real-valued amplitudes, only multiplexed Ry operations are needed to accomplish the state preparation.</p>
</div>
<p>Finally let’s consider another box type, namely the <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code>. This box can be used to prepare an arbitrary permutation of the computational basis states.
To construct the box we need to specify the permutation as a key-value pair where the key is the input basis state and the value is output.
Let’s construct a <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code> to perform the following mapping:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{gather}
|001\rangle \longmapsto |111\rangle \\
|111\rangle \longmapsto |001\rangle \\
|100\rangle \longmapsto |000\rangle \\
|000\rangle \longmapsto |100\rangle
\end{gather}\end{split}\]</div>
<p>We can construct a <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code> with a python dictionary where the basis states above are entered as key-value pairs.
For correctness if a basis state appears as key in the permutation dictionary then it must also appear and a value.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">ToffoliBox</span>

<span class="c1"># Specify the desired permutation of the basis states</span>
<span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">}</span>

<span class="c1"># Define box to perform the permutation</span>
<span class="n">perm_box</span> <span class="o">=</span> <span class="n">ToffoliBox</span><span class="p">(</span><span class="n">permutation</span><span class="o">=</span><span class="n">mapping</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>This permutation of basis states can be achieved with purely classical operations {X, CCX} hence the name <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code>.
In pytket however, the permutation is implemented efficently using a sequence of multiplexed rotations followed by a <code class="xref py py-class docutils literal notranslate"><span class="pre">DiagonalBox</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">perm_box</span><span class="o">.</span><span class="n">get_circuit</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-5bb255c3-ee90-42e8-87ca-d56bdc5ffd48&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;6180045d-f17d-4080-83aa-3f22f48f8198&#34;, &#34;op_map&#34;: [[[false, true], {&#34;params&#34;: [&#34;1&#34;], &#34;type&#34;: &#34;Ry&#34;}]], &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}, &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [2]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;c0c452b0-5699-470d-95be-d035edc0a307&#34;, &#34;op_map&#34;: [[[true, true], {&#34;params&#34;: [&#34;1&#34;], &#34;type&#34;: &#34;Ry&#34;}]], &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}, &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;1c125824-afaf-40e3-94fa-2463b5f8f4b8&#34;, &#34;op_map&#34;: [[[false, false], {&#34;params&#34;: [&#34;1&#34;], &#34;type&#34;: &#34;Ry&#34;}], [[false, true], {&#34;params&#34;: [&#34;1&#34;], &#34;type&#34;: &#34;Ry&#34;}]], &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}, &#34;type&#34;: &#34;MultiplexedRotationBox&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;box&#34;: {&#34;diagonal&#34;: [[[-1.0, 0.0]], [[1.0, 0.0]], [[1.0, 0.0]], [[1.0, 0.0]], [[1.0, 0.0]], [[-1.0, 0.0]], [[1.0, 0.0]], [[1.0, 0.0]]], &#34;id&#34;: &#34;79c4a501-f4f8-4b35-a093-4921f0de1152&#34;, &#34;type&#34;: &#34;DiagonalBox&#34;, &#34;upper_triangle&#34;: true}, &#34;type&#34;: &#34;DiagonalBox&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;5bb255c3-ee90-42e8-87ca-d56bdc5ffd48&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>Finally let’s append the <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code> onto our circuit preparing our Werner state to perform the permutation of basis states specified above.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state_circ</span><span class="o">.</span><span class="n">add_toffolibox</span><span class="p">(</span><span class="n">perm_box</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">state_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-ab3d5b5b-c9d0-44f1-b29a-2d3706d23312&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;a6914aa2-4544-4b66-9709-9a7dfe1b7d12&#34;, &#34;is_inverse&#34;: false, &#34;statevector&#34;: [[[0.0, 0.0]], [[0.5773502691896258, 0.0]], [[0.5773502691896258, 0.0]], [[0.0, 0.0]], [[0.5773502691896258, 0.0]], [[0.0, 0.0]], [[0.0, 0.0]], [[0.0, 0.0]]], &#34;type&#34;: &#34;StatePreparationBox&#34;}, &#34;type&#34;: &#34;StatePreparationBox&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;box&#34;: {&#34;id&#34;: &#34;bf9fe5d0-bc36-4a7b-bcbc-f9b553e28698&#34;, &#34;permutation&#34;: [[[false, false, false], [true, false, false]], [[false, false, true], [true, true, true]], [[true, false, false], [false, false, false]], [[true, true, true], [false, false, true]]], &#34;rotation_axis&#34;: &#34;Ry&#34;, &#34;type&#34;: &#34;ToffoliBox&#34;}, &#34;type&#34;: &#34;ToffoliBox&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [0]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [2]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;ab3d5b5b-c9d0-44f1-b29a-2d3706d23312&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_circ</span><span class="o">.</span><span class="n">get_statevector</span><span class="p">()</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>array([0.577, 0.   , 0.577, 0.   , 0.   , 0.   , 0.   , 0.577])
</pre></div>
</div>
</div>
</div>
<p>Looking at the statevector calculation we see that our <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code> has exchanged the coefficents of our Werner state so that the non-zero coefficents are now on the <span class="math notranslate nohighlight">\(|000\rangle\)</span> and <span class="math notranslate nohighlight">\(|111\rangle\)</span> bitstrings with the coefficent of <span class="math notranslate nohighlight">\(|010\rangle\)</span> remaining unchanged.</p>
</section>
</section>
<section id="importing-exporting-circuits">
<h2>Importing/Exporting Circuits<a class="headerlink" href="#importing-exporting-circuits" title="Permalink to this heading">#</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pytket</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s can be natively serializaed and deserialized from JSON-compatible dictionaries, using the <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_dict()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">from_dict()</span></code> methods. This is the method of serialization which supports the largest class of circuits, and provides the highest fidelity.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">YYPhase</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="n">circ_dict</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ_dict</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">(</span><span class="s1">&#39;w+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
    <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">circ_dict</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">new_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">new_circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{&#39;bits&#39;: [], &#39;commands&#39;: [{&#39;args&#39;: [[&#39;q&#39;, [0]]], &#39;op&#39;: {&#39;params&#39;: [&#39;0.1&#39;], &#39;type&#39;: &#39;Rx&#39;}}, {&#39;args&#39;: [[&#39;q&#39;, [0]], [&#39;q&#39;, [1]]], &#39;op&#39;: {&#39;type&#39;: &#39;CX&#39;}}, {&#39;args&#39;: [[&#39;q&#39;, [0]], [&#39;q&#39;, [1]]], &#39;op&#39;: {&#39;params&#39;: [&#39;0.2&#39;], &#39;type&#39;: &#39;YYPhase&#39;}}], &#39;created_qubits&#39;: [], &#39;discarded_qubits&#39;: [], &#39;implicit_permutation&#39;: [[[&#39;q&#39;, [0]], [&#39;q&#39;, [0]]], [[&#39;q&#39;, [1]], [&#39;q&#39;, [1]]]], &#39;phase&#39;: &#39;0.0&#39;, &#39;qubits&#39;: [[&#39;q&#39;, [0]], [&#39;q&#39;, [1]]]}


[Rx(0.1) q[0];, CX q[0], q[1];, YYPhase(0.2) q[0], q[1];]
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pytket</span></code> also supports interoperability with a number of other quantum software frameworks and programming languages for easy conversion of existing code and to provide users the freedom to choose their preferred input system and use available high-level packages.</p>
<p>OpenQASM is one of the current industry standards for low-level circuit description languages, featuring named quantum and classical registers, parameterised subroutines, and a limited form of conditional execution. Having bidirectional conversion support allows this to double up as a method of serializing circuits for later use.
Though less expressive than native dictionary serialization, it is widely supported and so serves as a platform-independent method of storing circuits.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.qasm</span> <span class="kn">import</span> <span class="n">circuit_from_qasm</span><span class="p">,</span> <span class="n">circuit_to_qasm_str</span>
<span class="kn">import</span> <span class="nn">tempfile</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">fd</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s2">&quot;.qasm&quot;</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;OPENQASM 2.0;</span>
<span class="s2">include &quot;qelib1.inc&quot;;</span>
<span class="s2">qreg q[2];</span>
<span class="s2">creg c[2];</span>
<span class="s2">h q[0];</span>
<span class="s2">cx q[0], q[1];</span>
<span class="s2">cz q[1], q[0];</span>
<span class="s2">measure q -&gt; c;</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">circuit_from_qasm</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circuit_to_qasm_str</span><span class="p">(</span><span class="n">circ</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>OPENQASM 2.0;
include &quot;qelib1.inc&quot;;

qreg q[2];
creg c[2];
h q[0];
cx q[0],q[1];
cz q[1],q[0];
measure q[0] -&gt; c[0];
measure q[1] -&gt; c[1];

</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The OpenQASM converters do not support circuits with <a class="reference external" href="https://cqcl.github.io/pytket/manual/manual_circuit.html#implicit-qubit-permutations">implicit qubit permutations</a> . This means that if a circuit contains such a permutation it will be ignored when exported to OpenQASM format.</p>
</div>
<p>The core <code class="docutils literal notranslate"><span class="pre">pytket</span></code> package additionally features a converter from Quipper, another circuit description language.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.quipper</span> <span class="kn">import</span> <span class="n">circuit_from_quipper</span>
<span class="kn">import</span> <span class="nn">tempfile</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">fd</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="s2">&quot;.quip&quot;</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;Inputs: 0:Qbit, 1:Qbit, 2:Qbit</span>
<span class="s2">QGate[&quot;X&quot;](0)</span>
<span class="s2">QGate[&quot;Y&quot;](1)</span>
<span class="s2">QGate[&quot;Z&quot;](2)</span>
<span class="s2">Outputs: 0:Qbit, 1:Qbit, 2:Qbit</span>
<span class="s2">&quot;&quot;&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">circuit_from_quipper</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
<span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[X q[0];, Y q[1];, Z q[2];]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are a few features of the Quipper language that are not supported by the converter, which are outlined in the <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/quipper.html">pytket.quipper documentation</a>.</p>
</div>
<p>Converters for other quantum software frameworks can optionally be included by installing the corresponding extension module. These are additional PyPI packages with names <code class="docutils literal notranslate"><span class="pre">pytket-X</span></code>, which extend the <code class="docutils literal notranslate"><span class="pre">pytket</span></code> namespace with additional features to interact with other systems, either using them as a front-end for circuit construction and high-level algorithms or targeting simulators and devices as backends.</p>
<p>For example, installing the <code class="docutils literal notranslate"><span class="pre">pytket-qiskit</span></code> package will add the <code class="docutils literal notranslate"><span class="pre">tk_to_qiskit</span></code> and <code class="docutils literal notranslate"><span class="pre">qiskit_to_tk</span></code> methods which convert between the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class from <code class="docutils literal notranslate"><span class="pre">pytket</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">qiskit.QuantumCircuit</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qiskit</span> <span class="kn">import</span> <span class="n">QuantumCircuit</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="n">qc</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">cx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">qc</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pytket.extensions.qiskit</span> <span class="kn">import</span> <span class="n">qiskit_to_tk</span><span class="p">,</span> <span class="n">tk_to_qiskit</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">qiskit_to_tk</span><span class="p">(</span><span class="n">qc</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>

<span class="n">qc2</span> <span class="o">=</span> <span class="n">tk_to_qiskit</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qc2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>     ┌───┐     ┌─┐                      
q_0: ┤ H ├──■──┤M├──────────────────────
     └───┘┌─┴─┐└╥┘┌─────────┐     ┌─┐   
q_1: ─────┤ X ├─╫─┤ Rz(π/2) ├──■──┤M├───
          └───┘ ║ └─────────┘┌─┴─┐└╥┘┌─┐
q_2: ───────────╫────────────┤ X ├─╫─┤M├
                ║            └───┘ ║ └╥┘
c: 3/═══════════╩══════════════════╩══╩═
                0                  1  2 
</pre></div>
</div>
</div>
</div>
</section>
<section id="symbolic-circuits">
<h2>Symbolic Circuits<a class="headerlink" href="#symbolic-circuits" title="Permalink to this heading">#</a></h2>
<p>In practice, it is very common for an experiment to use many circuits with similar structure but with varying gate parameters. In variational algorithms like VQE and QAOA, we are trying to explore the energy landscape with respect to the circuit parameters, realised as the angles of rotation gates. The only differences between iterations of the optimisation procedure are the specific angles of rotations in the circuits. Because the procedures of generating and compiling the circuits typically won’t care what the exact angles are, we can define the circuits abstractly, treating each parameter as an algebraic symbol. The circuit generation and compilation can then be pulled outside of the optimisation loop, being performed once and for all rather than once for each set of parameter values.</p>
<p><code class="docutils literal notranslate"><span class="pre">sympy</span></code> is a widely-used python package for symbolic expressions and algebraic manipulation, defining <code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.Symbol</span></code> objects to represent algebraic variables and using them in <code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.Expression</span></code> s to build mathematical statements and arithmetic expressions. Symbolic circuits are managed in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> by defining the circuit parameters as <code class="xref py py-class docutils literal notranslate"><span class="pre">sympy.Symbol</span></code> s, which can be passed in as arguments to the gates and later substituted for concrete values.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">OpType</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;beta&quot;</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">YYPhase</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>

<span class="n">s_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span><span class="mf">1.25</span><span class="p">}</span>
<span class="n">circ</span><span class="o">.</span><span class="n">symbol_substitution</span><span class="p">(</span><span class="n">s_map</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(alpha) q[0];, Rx(-2*alpha) q[1];, CX q[0], q[1];, YYPhase(beta) q[0], q[1];]
[Rx(0.3) q[0];, Rx(3.4) q[1];, CX q[0], q[1];, YYPhase(1.25) q[0], q[1];]
</pre></div>
</div>
</div>
</div>
<p>It is important to note that the units of the parameter values will still be in half-turns, and so may need conversion to/from radians if there is important semantic meaning to the parameter values. This can either be done at the point of interpreting the values, or by embedding the conversion into the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pi</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">)</span>     <span class="c1"># suppose that alpha is given in radians</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>       <span class="c1"># convert alpha to half-turns when adding gates</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">s_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">}</span>
<span class="n">circ</span><span class="o">.</span><span class="n">symbol_substitution</span><span class="p">(</span><span class="n">s_map</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(0.25) q[0];, CX q[0], q[1];, Ry(3.75) q[0];]
</pre></div>
</div>
</div>
</div>
<p>Substitution need not be for concrete values, but is defined more generally to allow symbols to be replaced by arbitrary expressions, including other symbols. This allows for alpha-conversion or to look at special cases with redundant parameters.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a b c&quot;</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">s_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="n">a</span><span class="p">}</span>  <span class="c1"># replacement happens simultaneously, and not recursively</span>
<span class="n">circ</span><span class="o">.</span><span class="n">symbol_substitution</span><span class="p">(</span><span class="n">s_map</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(2*a) q[0];, Rx(b) q[1];, CX q[0], q[1];, Ry(a) q[0];, Ry(a) q[1];]
</pre></div>
</div>
</div>
</div>
<p>There are currently no simulators or devices that can run symbolic circuits algebraically, so every symbol must be instantiated before running. At any time, you can query the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> object for the set of free symbols it contains to check what would need to be instantiated before it can be run.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a, b&quot;</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">symbol_substitution</span><span class="p">({</span><span class="n">a</span><span class="p">:</span><span class="mf">0.2</span><span class="p">})</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">is_symbolic</span><span class="p">())</span>   <span class="c1"># returns True when free_symbols() is non-empty</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>{b}
True
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There are some minor drawbacks associated with symbolic compilation. When using <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.EulerAngleReduction">Euler-angle equations</a> or quaternions for merging adjacent rotation gates, the resulting angles are given by some lengthy trigonometric expressions which cannot be evaluated down to just a number when one of the original angles was parameterised; this can lead to unhelpfully long expressions for the angles of some gates in the compiled circuit. It is also not possible to apply the <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/passes.html#pytket.passes.KAKDecomposition">KAK decomposition</a> to simplify a parameterised circuit, so that pass will only apply to non-parameterised subcircuits, potentially missing some valid opportunities for optimisation.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To see how to use symbolic compilation in a variational experiment, have a look at our <a class="reference external" href="https://github.com/CQCL/pytket/blob/main/examples/ucc_vqe.ipynb">VQE (UCCSD) example</a>.</p>
</div>
<section id="symbolic-unitaries-and-states">
<h3>Symbolic unitaries and states<a class="headerlink" href="#symbolic-unitaries-and-states" title="Permalink to this heading">#</a></h3>
<p>In <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/utils.html#module-pytket.utils.symbolic" title="(in pytket v1.15)"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pytket.utils.symbolic</span></code></a> we provide functions <code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_to_symbolic_unitary()</span></code>, which can calculate the unitary representation of a possibly symbolic circuit, and <code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_apply_symbolic_statevector()</span></code>, which can apply a symbolic circuit to an input statevector and return the output state (effectively simulating it).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.utils.symbolic</span> <span class="kn">import</span> <span class="n">circuit_apply_symbolic_statevector</span><span class="p">,</span> <span class="n">circuit_to_symbolic_unitary</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">Symbol</span><span class="p">,</span> <span class="n">pi</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">pi</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># All zero input state is assumed if no initial state is provided</span>
<span class="n">display</span><span class="p">(</span><span class="n">circuit_apply_symbolic_statevector</span><span class="p">(</span><span class="n">circ</span><span class="p">))</span>
<span class="n">circuit_to_symbolic_unitary</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\displaystyle \left[\begin{matrix}\cos{\left(\frac{\alpha}{2} \right)}\\0\\0\\- i \sin{\left(\frac{\alpha}{2} \right)}\end{matrix}\right]\end{split}\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\begin{split}\displaystyle \left[\begin{matrix}\cos{\left(\frac{\alpha}{2} \right)} &amp; 0 &amp; - i \sin{\left(\frac{\alpha}{2} \right)} &amp; 0\\0 &amp; \cos{\left(\frac{\alpha}{2} \right)} &amp; 0 &amp; - i \sin{\left(\frac{\alpha}{2} \right)}\\0 &amp; - i \sin{\left(\frac{\alpha}{2} \right)} &amp; 0 &amp; \cos{\left(\frac{\alpha}{2} \right)}\\- i \sin{\left(\frac{\alpha}{2} \right)} &amp; 0 &amp; \cos{\left(\frac{\alpha}{2} \right)} &amp; 0\end{matrix}\right]\end{split}\]</div>
</div>
</div>
<p>The unitaries are calculated using the unitary representation of each <a class="reference external" href="https://cqcl.github.io/tket/pytket/api/optype.html">OpType</a> , and according to the default <a class="reference external" href="manual_backend.html#interpreting-results">ILO BasisOrder convention used in backends</a>.
The outputs are sympy <a class="reference external" href="https://docs.sympy.org/latest/modules/matrices/immutablematrices.html">ImmutableMatrix</a> objects, and use the same symbols as in the circuit, so can be further substituted and manipulated.
The conversion functions use the <a class="reference external" href="https://docs.sympy.org/latest/modules/physics/quantum/index.html">sympy Quantum Mechanics module</a>, see also the <code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_to_symbolic_gates()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">circuit_apply_symbolic_qubit()</span></code> functions to see how to work with those objects directly.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unitaries corresponding to circuits with <span class="math notranslate nohighlight">\(n\)</span> qubits have dimensions <span class="math notranslate nohighlight">\(2^n \times 2^n\)</span>, so are computationally very expensive to calculate. Symbolic calculation is also computationally costly, meaning calculation of symbolic unitaries is only really feasible for very small circuits (of up to a few qubits in size). These utilities are provided as way to test the design of small subcircuits to check they are performing the intended unitary. Note also that as mentioned above, compilation of a symbolic circuit can generate long symbolic expressions; converting these circuits to a symbolic unitary could then result in a matrix object that is very hard to work with or interpret.</p>
</div>
</section>
</section>
<section id="advanced-topics">
<h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permalink to this heading">#</a></h2>
<section id="custom-parameterised-gates">
<h3>Custom parameterised Gates<a class="headerlink" href="#custom-parameterised-gates" title="Permalink to this heading">#</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> construction is good for subroutines where the instruction sequence is fixed. The <code class="xref py py-class docutils literal notranslate"><span class="pre">CustomGateDef</span></code> construction generalises this to construct parameterised subroutines by binding symbols in the definition circuit and instantiating them at each instance. Any symbolic <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> can be provided as the subroutine definition. Remaining symbols that are not bound are treated as free symbols in the global scope.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">CustomGateDef</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>

<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s2">&quot;a b&quot;</span><span class="p">)</span>
<span class="n">def_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">def_circ</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">def_circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">def_circ</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">def_circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">def_circ</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">gate_def</span> <span class="o">=</span> <span class="n">CustomGateDef</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;MyCRx&quot;</span><span class="p">,</span> <span class="n">def_circ</span><span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_custom_gate</span><span class="p">(</span><span class="n">gate_def</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_custom_gate</span><span class="p">(</span><span class="n">gate_def</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">free_symbols</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[MyCRx(0.2) q[0], q[1];, MyCRx(0.3) q[0], q[2];]
{b}
</pre></div>
</div>
</div>
</div>
</section>
<section id="clifford-tableaux">
<h3>Clifford Tableaux<a class="headerlink" href="#clifford-tableaux" title="Permalink to this heading">#</a></h3>
<p>The Clifford (a.k.a. stabilizer) fragment of quantum theory is known to exhibit efficient classical representations of states and unitaries. This allows for short descriptions that can fully characterise a state/unitary and efficient circuit simulation. Whilst the Clifford group can be characterised as the operations generated by <cite>CX</cite>, <cite>H</cite>, and <cite>S</cite> gates with qubit initialisation in the <span class="math notranslate nohighlight">\(|0\rangle\)</span> state, it is also the largest group of operations under which the Pauli group is closed, i.e. for any tensor of Paulis <span class="math notranslate nohighlight">\(P\)</span> and Clifford operation <span class="math notranslate nohighlight">\(C\)</span>, <span class="math notranslate nohighlight">\(CPC^\dagger\)</span> is also a tensor of Paulis.</p>
<p>Any state <span class="math notranslate nohighlight">\(|\psi\rangle\)</span> in the Clifford fragment is uniquely identified by those tensors of Pauli operators that stabilize it (those <span class="math notranslate nohighlight">\(P\)</span> such that <span class="math notranslate nohighlight">\(P|\psi\rangle = |\psi\rangle\)</span>). These stabilizers form a group of size <span class="math notranslate nohighlight">\(2^n\)</span> for an <span class="math notranslate nohighlight">\(n\)</span> qubit state, but it is sufficient to identify <span class="math notranslate nohighlight">\(n\)</span> independent generators to specify the group. If a Clifford gate <span class="math notranslate nohighlight">\(C\)</span> is applied to the state, each generator <span class="math notranslate nohighlight">\(P\)</span> can be updated to <span class="math notranslate nohighlight">\(P' = CPC^\dagger\)</span> since <span class="math notranslate nohighlight">\(C|\psi\rangle = CP|\psi\rangle = (CPC^\dagger)C|\psi\rangle\)</span>. We can therefore characterise each Clifford operation by its actions on generators of the Pauli group, giving us the Clifford tableau form. In <code class="docutils literal notranslate"><span class="pre">pytket</span></code>, the <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitaryTableau</span></code> class uses the binary symplectic representation from Aaronson and Gottesman <a class="reference internal" href="#aaro2004" id="id8"><span>[Aaro2004]</span></a>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">OpType</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.tableau</span> <span class="kn">import</span> <span class="n">UnitaryTableau</span>

<span class="n">tab</span> <span class="o">=</span> <span class="n">UnitaryTableau</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">tab</span><span class="o">.</span><span class="n">apply_gate_at_end</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">S</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">0</span><span class="p">)])</span>
<span class="n">tab</span><span class="o">.</span><span class="n">apply_gate_at_end</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CX</span><span class="p">,</span> <span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tab</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>X@q[0]	-&gt;	1 0 0   1 0 0   1
X@q[1]	-&gt;	0 1 1   0 0 0   0
X@q[2]	-&gt;	0 0 1   0 0 0   0
--
Z@q[0]	-&gt;	0 0 0   1 0 0   0
Z@q[1]	-&gt;	0 0 0   0 1 0   0
Z@q[2]	-&gt;	0 0 0   0 1 1   0

</pre></div>
</div>
</div>
</div>
<p>The way to interpret this format is that, for example, the top rows state that the unitary transforms <span class="math notranslate nohighlight">\(X_0 I_1 I_2\)</span> at its input to <span class="math notranslate nohighlight">\(-Y_0 I_1 I_2\)</span> at its output, and it transforms <span class="math notranslate nohighlight">\(I_0 X_1 I_2\)</span> to <span class="math notranslate nohighlight">\(I_0 X_1 X_2\)</span>.</p>
<p>The primary use for tableaux in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> is as a scalable means of specifying a Clifford unitary for insertion into a circuit as a Box. This can then be decomposed into basic gates during compilation.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">DecomposeBoxes</span>
<span class="kn">from</span> <span class="nn">pytket.tableau</span> <span class="kn">import</span> <span class="n">UnitaryTableauBox</span>

<span class="n">box</span> <span class="o">=</span> <span class="n">UnitaryTableauBox</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
    <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="n">DecomposeBoxes</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">circ</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[X q[0]; X q[1]; X q[2]; Z q[1]; S q[2]; CX q[1], q[0]; S q[2]; S q[0]; S q[1]; H q[2]; CX q[1], q[0]; S q[2]; S q[0]; S q[1]; V q[2]; H q[0]; H q[1]; CX q[1], q[0]; S q[0]; S q[1]; CX q[1], q[0]; CX q[1], q[0]; V q[0]; ]
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The current decomposition method for tableaux is not particularly efficient in terms of gate count, so consider using higher optimisation levels when compiling to help reduce the gate cost.</p>
</div>
<p>The data structure used here for tableaux is intended for compilation use. For fast simulation of Clifford circuits, we recommend using the <code class="xref py py-class docutils literal notranslate"><span class="pre">StimBackend</span></code> from <code class="docutils literal notranslate"><span class="pre">pytket-stim</span></code>, the <code class="xref py py-class docutils literal notranslate"><span class="pre">SimplexBackend</span></code> from <code class="docutils literal notranslate"><span class="pre">pytket-pysimplex</span></code> (optimized for large sparse circuits), or the <code class="xref py py-class docutils literal notranslate"><span class="pre">AerBackend</span></code> from <code class="docutils literal notranslate"><span class="pre">pytket-qiskit</span></code>. Future versions of <code class="docutils literal notranslate"><span class="pre">pytket</span></code> may include improved decompositions from tableaux, as well as more flexible tableaux to represent stabilizer states, isometries, and diagonalisation circuits.</p>
</section>
<section id="classical-and-conditional-operations">
<h3>Classical and conditional operations<a class="headerlink" href="#classical-and-conditional-operations" title="Permalink to this heading">#</a></h3>
<p>Moving beyond toy circuit examples, many applications of quantum computing
require looking at circuits as POVMs for extra expressivity, or introducing
error-correcting schemes to reduce the effective noise. Each of these requires
performing measurements mid-circuit and then performing subsequent gates
conditional on the classical value of the measurement result, or on the results
of calculations on the results.</p>
<p>Any <code class="docutils literal notranslate"><span class="pre">pytket</span></code> operation can be made conditional at the point of adding it to
the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> by providing the <code class="docutils literal notranslate"><span class="pre">condition</span></code> kwarg. The interpretation
of <code class="docutils literal notranslate"><span class="pre">circ.G(q,</span> <span class="pre">condition=reg[0])</span></code> is: “if the  bit <code class="docutils literal notranslate"><span class="pre">reg[0]</span></code> is set to 1, then
perform <code class="docutils literal notranslate"><span class="pre">G(q)</span></code>”.
Conditions on more complicated expressions over the values of <a class="reference external" href="../../tket/pytket/api/circuit.html#pytket.circuit.Bit">Bit</a> and <a class="reference external" href="../../tket/pytket/api/circuit.html#pytket.circuit.BitRegister">BitRegister</a> are also
possible, expressed as conditions on the results of expressions involving
bitwise AND (&amp;), OR (|) and XOR (^) operations. In the case of registers, you
can also express arithmetic operations: add (+), subtract (-), multiply (*),
floor/integer division (//), left shift (&lt;&lt;) and right shift (&gt;&gt;).
For example a gate can be made conditional on the result of a bitwise XOR of
registers <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code> being larger than 4 by writing <code class="docutils literal notranslate"><span class="pre">circ.G(q,</span>
<span class="pre">condition=reg_gt(a</span> <span class="pre">^</span> <span class="pre">b</span> <span class="pre">^</span> <span class="pre">c,</span> <span class="pre">4))</span></code>.
When such a condition is added, the result of the expression is written to a
scratch bit or register, and the gate is made conditional on the value of the
scratch variable.
For comparison of registers, a special <code class="docutils literal notranslate"><span class="pre">RangePredicate</span></code> type is used to encode
the result of the comparison onto a scratch bit.
See the <a class="reference external" href="../../tket/pytket/api/classical.html">API reference</a> for more on the
possible expressions and predicates.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Circuit</span><span class="p">,</span>
    <span class="n">BitRegister</span><span class="p">,</span>
    <span class="n">if_bit</span><span class="p">,</span>
    <span class="n">if_not_bit</span><span class="p">,</span>
    <span class="n">reg_eq</span><span class="p">,</span>
    <span class="n">reg_geq</span><span class="p">,</span>
    <span class="n">reg_gt</span><span class="p">,</span>
    <span class="n">reg_leq</span><span class="p">,</span>
    <span class="n">reg_lt</span><span class="p">,</span>
    <span class="n">reg_neq</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># create a circuit and add quantum and classical registers</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">qreg</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_q_register</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">reg_a</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1"># another way of adding a register to the Circuit</span>
<span class="n">reg_b</span> <span class="o">=</span> <span class="n">BitRegister</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="n">reg_b</span><span class="p">)</span>
<span class="n">reg_c</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c1"># if (reg_a[0] == 1)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">if_bit</span><span class="p">(</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># if (reg_a[2] == 0)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">if_not_bit</span><span class="p">(</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># compound logical expressions</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="p">(</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">if_not_bit</span><span class="p">(</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
<span class="n">big_exp</span> <span class="o">=</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">|</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">^</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg_a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="c1"># syntactic sugar for big_exp = BitOr(reg_a[0], BitXor(reg_a[1], BitAnd(reg_a[2], reg_a[3])))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">big_exp</span><span class="p">)</span>

<span class="c1"># Register comparisons</span>

<span class="c1"># if (reg_a == 3)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_eq</span><span class="p">(</span><span class="n">reg_a</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># if (reg_c != 6)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_neq</span><span class="p">(</span><span class="n">reg_c</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="c1"># if (reg_b &lt; 6)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_lt</span><span class="p">(</span><span class="n">reg_b</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># if (reg_b &gt; 3)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Z</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_gt</span><span class="p">(</span><span class="n">reg_b</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># if (reg_c &lt;= 6)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_leq</span><span class="p">(</span><span class="n">reg_c</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="c1"># if (reg_a &gt;= 3)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">T</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_geq</span><span class="p">(</span><span class="n">reg_a</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># compound register expressions</span>
<span class="n">big_reg_exp</span> <span class="o">=</span> <span class="p">(</span><span class="n">reg_a</span> <span class="o">&amp;</span> <span class="n">reg_b</span><span class="p">)</span> <span class="o">|</span> <span class="n">reg_c</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="n">qreg</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">qreg</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_eq</span><span class="p">(</span><span class="n">big_reg_exp</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[IF ([a[0]] == 1) THEN H q[0]; IF ([a[2]] == 0) THEN T q[1]; ClassicalExpBox a[2], a[3], tk_SCRATCH_BIT[0]; ClassicalExpBox a[2], a[3], tk_SCRATCH_BIT[1]; ClassicalExpBox a[0], a[1], a[2], a[3], tk_SCRATCH_BIT[2]; RangePredicate([3,3]) a[0], a[1], a[2], a[3], tk_SCRATCH_BIT[3]; RangePredicate([5,5]) c[0], c[1], c[2], tk_SCRATCH_BIT[4]; RangePredicate([0,5]) b[0], b[1], b[2], tk_SCRATCH_BIT[5]; RangePredicate([4,4294967295]) b[0], b[1], b[2], tk_SCRATCH_BIT[6]; RangePredicate([0,6]) c[0], c[1], c[2], tk_SCRATCH_BIT[7]; RangePredicate([3,4294967295]) a[0], a[1], a[2], a[3], tk_SCRATCH_BIT[8]; ClassicalExpBox a[0], a[1], a[2], a[3], b[0], b[1], b[2], c[0], c[1], c[2], tk_SCRATCH_BITREG_0[0], tk_SCRATCH_BITREG_0[1], tk_SCRATCH_BITREG_0[2]; IF ([a[0]] == 1) THEN X q[0]; IF ([tk_SCRATCH_BIT[1]] == 0) THEN Z q[1]; IF ([tk_SCRATCH_BIT[5]] == 1) THEN X q[3]; IF ([tk_SCRATCH_BIT[4]] == 0) THEN Y q[4]; IF ([tk_SCRATCH_BIT[6]] == 1) THEN Z q[5]; IF ([tk_SCRATCH_BIT[7]] == 1) THEN S q[6]; IF ([tk_SCRATCH_BIT[8]] == 1) THEN T q[7]; RangePredicate([3,3]) tk_SCRATCH_BITREG_0[0], tk_SCRATCH_BITREG_0[1], tk_SCRATCH_BITREG_0[2], tk_SCRATCH_BIT[9]; IF ([tk_SCRATCH_BIT[0]] == 1) THEN Z q[0]; IF ([tk_SCRATCH_BIT[2]] == 1) THEN CX q[1], q[2]; IF ([tk_SCRATCH_BIT[9]] == 1) THEN CX q[3], q[4]; IF ([tk_SCRATCH_BIT[3]] == 1) THEN H q[2]; ]
</pre></div>
</div>
</div>
</div>
<p>So far we’ve looked at conditioning the application of a gate on bits,
registers, or expressions over those. We can also write some more standard
classical computations by assigning the result of some computation to output
bits or registers. We can also set the value or copy the contents of one resource
in to another. Note in the examples below to express something like <cite>&lt;var&gt; =
&lt;exp&gt;</cite> we use circuit methods (like <code class="docutils literal notranslate"><span class="pre">add_c_setreg</span></code>, or
<code class="docutils literal notranslate"><span class="pre">add_classicalexpbox_register</span></code>) that take <cite>&lt;exp&gt;</cite> as the first input and <cite>&lt;var&gt;</cite>
as the second. Note that these classical operations can be conditional on other
classical operations, just like quantum operations.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">reg_gt</span>

<span class="c1"># create a circuit and add some classical registers</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">reg_a</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">reg_b</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">reg_c</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">add_c_register</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>


<span class="c1"># Write to classical registers</span>

<span class="c1"># a = 3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_setreg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">reg_a</span><span class="p">)</span>
<span class="c1"># a[0] = 1</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_setbits</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># Copy: b = a</span>
<span class="c1"># b is smaller than a so the first 3 bits of a will be copied</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_copyreg</span><span class="p">(</span><span class="n">reg_a</span><span class="p">,</span> <span class="n">reg_b</span><span class="p">)</span>
<span class="c1"># b[1] = a[2]</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_copybits</span><span class="p">([</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">reg_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

<span class="c1"># Conditional classical operation</span>

<span class="c1"># if (a &gt; 1) b = 3</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_c_setreg</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">reg_b</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">reg_gt</span><span class="p">(</span><span class="n">reg_a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Write out the results of logical expressions</span>

<span class="c1"># c = a ^ b</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_register</span><span class="p">(</span><span class="n">reg_a</span> <span class="o">^</span> <span class="n">reg_b</span><span class="p">,</span> <span class="n">reg_c</span><span class="p">)</span>
<span class="c1"># c[0] = a[1] &amp; b[2]</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_bit</span><span class="p">(</span><span class="n">reg_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">reg_b</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="n">reg_c</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

<span class="c1"># Register arithmetic</span>

<span class="c1"># c = a + b // c (note the use of the floor divide symbol)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_register</span><span class="p">(</span><span class="n">reg_a</span> <span class="o">+</span> <span class="n">reg_b</span> <span class="o">//</span> <span class="n">reg_c</span><span class="p">,</span> <span class="n">reg_c</span><span class="p">)</span>
<span class="c1"># a = a - b * c</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_register</span><span class="p">(</span><span class="n">reg_a</span> <span class="o">-</span> <span class="n">reg_b</span> <span class="o">*</span> <span class="n">reg_c</span><span class="p">,</span> <span class="n">reg_a</span><span class="p">)</span>
<span class="c1"># a = a &lt;&lt; 2</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_register</span><span class="p">(</span><span class="n">reg_a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">reg_a</span><span class="p">)</span>
<span class="c1"># c = b &gt;&gt; 1</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_classicalexpbox_register</span><span class="p">(</span><span class="n">reg_b</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reg_c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-none notranslate"><div class="highlight"><pre><span></span>[SetBits(1100) a[0], a[1], a[2], a[3]; SetBits(1) a[0]; CopyBits a[0], a[1], a[2], b[0], b[1], b[2]; RangePredicate([2,4294967295]) a[0], a[1], a[2], a[3], tk_SCRATCH_BIT[0]; CopyBits a[2], b[1]; IF ([tk_SCRATCH_BIT[0]] == 1) THEN SetBits(110) b[0], b[1], b[2]; ClassicalExpBox a[0], a[1], a[2], a[3], b[0], b[1], b[2], c[0], c[1], c[2]; ClassicalExpBox a[1], b[2], c[0]; ClassicalExpBox a[0], a[1], a[2], a[3], b[0], b[1], b[2], c[0], c[1], c[2]; ClassicalExpBox b[0], b[1], b[2], c[0], c[1], c[2], a[0], a[1], a[2], a[3]; ClassicalExpBox a[0], a[1], a[2], a[3]; ClassicalExpBox b[0], b[1], b[2], c[0], c[1], c[2]; ]
</pre></div>
</div>
</div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unlike most uses of readouts in <code class="docutils literal notranslate"><span class="pre">pytket</span></code>, register comparisons expect a little-endian value, e.g. in the above example <code class="docutils literal notranslate"><span class="pre">condition=reg_eq(reg_a,</span> <span class="pre">3)</span></code> (representing the little-endian binary string <code class="docutils literal notranslate"><span class="pre">110000...</span></code>) is triggered when <code class="docutils literal notranslate"><span class="pre">reg_a[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">reg_a[1]</span></code> are in state <code class="docutils literal notranslate"><span class="pre">1</span></code> and the remainder of the register is in state <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This feature is only usable on a limited selection of devices and simulators which support conditional gates or classical operations.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AerBackend</span></code> (from <code class="docutils literal notranslate"><span class="pre">pytket-qiskit</span></code>) can support the OpenQasm model,
where gates can only be conditional on an entire classical register being an
exact integer value. Bitwise logical operations and register arithmetic are not supported.
Therefore only conditions of the form
<code class="docutils literal notranslate"><span class="pre">condition=reg_eq(reg,</span> <span class="pre">val)</span></code> are valid.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">QuantinuumBackend</span></code> (from <code class="docutils literal notranslate"><span class="pre">pytket-quantinuum</span></code>)
can support the full range of expressions and comparisons shown above.</p>
</div>
</section>
<section id="circuit-level-operations">
<h3>Circuit-Level Operations<a class="headerlink" href="#circuit-level-operations" title="Permalink to this heading">#</a></h3>
<p>Systematic modifications to a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> object can go beyond simply adding gates one at a time. For example, given a unitary <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>, we may wish to generate its inverse for the purposes of uncomputation of ancillae or creating conjugation circuits to diagonalise an operator as in the sample below.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>

<span class="c1"># we want a circuit for E = exp(-i pi (0.3 XX + 0.1 YY))</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># find C such that C; Rx(a, 0); C^dagger performs exp(-i a pi XX/2)</span>
<span class="c1"># and C; Rz(b, 1); C^dagger performs exp(-i b pi YY/2)</span>
<span class="n">conj</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">conj</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">V</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">conj_dag</span> <span class="o">=</span> <span class="n">conj</span><span class="o">.</span><span class="n">dagger</span><span class="p">()</span>

<span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conj</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conj_dag</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>Generating the transpose of a unitary works similarly using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.transpose()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since it is not possible to construct the inverse of an arbitrary POVM, the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.dagger()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.transpose()</span></code> methods will fail if there are any measurements, resets, or other operations that they cannot directly invert.</p>
</div>
</section>
<section id="id9">
<h3>Implicit Qubit Permutations<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> class is built as a DAG to help follow the paths of resources and represent the circuit canonically up to trivial commutations. Each of the edges represents a resource passing from one instruction to the next, so we could represent SWAPs (and general permutations) by connecting the predecessors of the SWAP instruction to the opposite successors. This eliminates the SWAP instruction from the graph (meaning we would no longer perform the operation at runtime) and could enable the compiler to spot additional opportunities for simplification. One example of this in practice is the ability to convert a pair of CXs in opposite directions to just a single CX (along with an implicit SWAP that isn’t actually performed).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">pytket.utils</span> <span class="kn">import</span> <span class="n">Graph</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span><span class="o">.</span><span class="n">get_DAG</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[CX q[0], q[1];, CX q[1], q[0];, Rx(0.2) q[1];, CZ q[0], q[1];]
</pre></div>
</div>
<img alt="_images/manual_circuit_60_1.svg" src="_images/manual_circuit_60_1.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">CliffordSimp</span>

<span class="n">CliffordSimp</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">implicit_qubit_permutation</span><span class="p">())</span>
<span class="n">Graph</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span><span class="o">.</span><span class="n">get_DAG</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[TK1(1.5, 2.2, 0) q[0];, TK1(0, 0, 0.5) q[1];, CX q[1], q[0];, TK1(0, 0, 0.5) q[0];]
{q[0]: q[1], q[1]: q[0], q[2]: q[2], q[3]: q[3]}
</pre></div>
</div>
<img alt="_images/manual_circuit_61_1.svg" src="_images/manual_circuit_61_1.svg" /></div>
</div>
<p>This procedure essentially exploits the naturality of the symmetry operator in the resource theory to push it to the end of the circuit: the <code class="docutils literal notranslate"><span class="pre">Rx</span></code> gate has moved from qubit <code class="docutils literal notranslate"><span class="pre">q[1]</span></code> to <code class="docutils literal notranslate"><span class="pre">q[0]</span></code> and can be commuted through to the start. This is automatically considered when composing two <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s together.</p>
<p>The permutation has been reduced to something implicit in the graph, and we now find that tracing a path from an input can reach an output with a different <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code>. Since this permutation is missing in the command sequence, simulating the circuit would only give the correct state up to a permutation of the qubits. This does not matter when running on real devices where the final quantum system is discarded after use, but is detectable when using a statevector simulator. This is handled automatically by <code class="docutils literal notranslate"><span class="pre">pytket</span></code> backends, but care should be taken when reading from the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> directly - two quantum <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> s can have the same sequence of instructions but different unitaries because of implicit permutations. This permutation information is typically dropped when exporting to another software framework. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.implicit_qubit_permutation()</span></code> method can be used to inspect such a permutation.</p>
</section>
<section id="modifying-operations-within-circuits">
<h3>Modifying Operations Within Circuits<a class="headerlink" href="#modifying-operations-within-circuits" title="Permalink to this heading">#</a></h3>
<p>Symbolic parameters allow one to construct a circuit with some not-yet-assigned parameters, and later (perhaps after some optimization), to instantiate them with different values. Occasionally, however, one may desire more flexibility in substituting operations within a circuit. For example, one may wish to apply controls from a certain qubit to certain operations, or to insert or remove certain operations.</p>
<p>This can be achieved with <code class="docutils literal notranslate"><span class="pre">pytket</span></code>, provided the mutable operations are tagged during circuit construction with identifying names (which can be arbitrary strings). If two operations are given the same name then they belong to the same “operation group”; they can (and must) then be substituted simultaneously.</p>
<p>Both primitive gates and boxes can be tagged and substituted in this way. The only constraint is that the signature (number and order of quantum and classical wires) of the substituted operation must match that of the original operation in the circuit. (It follows that all operations in the same group must have the same signature. An attempt to add an operation with an existing name with a mismatching signature will fail.)</p>
<p>To add gates or boxes to a circuit with specified op group names, simply pass the name as a keyword argument <code class="docutils literal notranslate"><span class="pre">opgroup</span></code> to the method that adds the gate or box. To substitute all operations in a group, use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Circuit.substitute_named()</span></code> method. This can be used to substitute a circuit, an operation or a box into the existing circuit.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">CircBox</span>

<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;rotations&quot;</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="mf">0.75</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;rotations&quot;</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;special one&quot;</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">cbox</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">CY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">cbox</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;Fred&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[rotations] Rz(0.25) q[0];, [special one] H q[2];, CX q[0], q[1];, [rotations] Ry(0.75) q[1];, CX q[2], q[1];, [Fred] CircBox q[0], q[1];, [Fred] CX q[1], q[2];]
</pre></div>
</div>
</div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">Op</span>

<span class="c1"># Substitute a new 1-qubit circuit for all ops in the &quot;rotations&quot; group:</span>
<span class="n">newcirc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.125</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Ry</span><span class="p">(</span><span class="mf">0.875</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">substitute_named</span><span class="p">(</span><span class="n">newcirc</span><span class="p">,</span> <span class="s2">&quot;rotations&quot;</span><span class="p">)</span>
<span class="c1"># Replace the &quot;special one&quot; with a different op:</span>
<span class="n">newop</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">substitute_named</span><span class="p">(</span><span class="n">newop</span><span class="p">,</span> <span class="s2">&quot;special one&quot;</span><span class="p">)</span>
<span class="c1"># Substitute a box for the &quot;Fred&quot; group:</span>
<span class="n">newcbox</span> <span class="o">=</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">Circuit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">substitute_named</span><span class="p">(</span><span class="n">newcbox</span><span class="p">,</span> <span class="s2">&quot;Fred&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[Rx(0.125) q[0];, [special one] T q[2];, Ry(0.875) q[0];, CX q[0], q[1];, Rx(0.125) q[1];, Ry(0.875) q[1];, CX q[2], q[1];, [Fred] CircBox q[0], q[1];, [Fred] CircBox q[1], q[2];]
</pre></div>
</div>
</div>
</div>
<p>Note that when an operation or box is substituted in, the op group name is retained (and further substitutions can be made). When a circuit is substituted in, the op group name disappears.</p>
<p>To remove an operation, one can replace it with an empty circuit.</p>
<p>To add a control to an operation, one can add the original operation as a <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> with one unused qubit, and subtitute it with a <code class="xref py py-class docutils literal notranslate"><span class="pre">QControlBox</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.circuit</span> <span class="kn">import</span> <span class="n">QControlBox</span>

<span class="k">def</span> <span class="nf">with_empty_qubit</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">Op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CircBox</span><span class="p">:</span>
    <span class="n">n_qb</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">n_qubits</span>
    <span class="k">return</span> <span class="n">CircBox</span><span class="p">(</span><span class="n">Circuit</span><span class="p">(</span><span class="n">n_qb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">add_gate</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_qb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))))</span>

<span class="k">def</span> <span class="nf">with_control_qubit</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="n">Op</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">QControlBox</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">QControlBox</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">h_op</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">cx_op</span> <span class="o">=</span> <span class="n">Op</span><span class="o">.</span><span class="n">create</span><span class="p">(</span><span class="n">OpType</span><span class="o">.</span><span class="n">CX</span><span class="p">)</span>
<span class="n">h_0_cbox</span> <span class="o">=</span> <span class="n">with_empty_qubit</span><span class="p">(</span><span class="n">h_op</span><span class="p">)</span>
<span class="n">h_q_qbox</span> <span class="o">=</span> <span class="n">with_control_qubit</span><span class="p">(</span><span class="n">h_op</span><span class="p">)</span>
<span class="n">cx_0_cbox</span> <span class="o">=</span> <span class="n">with_empty_qubit</span><span class="p">(</span><span class="n">cx_op</span><span class="p">)</span>
<span class="n">cx_q_qbox</span> <span class="o">=</span> <span class="n">with_control_qubit</span><span class="p">(</span><span class="n">cx_op</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">h_0_cbox</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;hgroup&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">cx_0_cbox</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;cxgroup&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">h_0_cbox</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;hgroup&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">add_circbox</span><span class="p">(</span><span class="n">cx_0_cbox</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">opgroup</span><span class="o">=</span><span class="s2">&quot;cxgroup&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">Y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">substitute_named</span><span class="p">(</span><span class="n">h_q_qbox</span><span class="p">,</span> <span class="s2">&quot;hgroup&quot;</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">substitute_named</span><span class="p">(</span><span class="n">cx_q_qbox</span><span class="p">,</span> <span class="s2">&quot;cxgroup&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">get_commands</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[X q[0];, Y q[1];, [hgroup] qif (q[2]) H q[0];, [cxgroup] qif (q[2]) CX q[0], q[1];, Y q[0];, X q[1];, [hgroup] qif (q[2]) H q[1];, [cxgroup] qif (q[2]) CX q[1], q[0];, X q[0];, Y q[1];]
</pre></div>
</div>
</div>
</div>
<div role="list" class="citation-list">
<div class="citation" id="cowt2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">Cowt2020</a><span class="fn-bracket">]</span></span>
<p>Cowtan, A. and Dilkes, S. and Duncan and R., Simmons, W and Sivarajah, S., 2020. Phase Gadget Synthesis for Shallow Circuits. Electronic Proceedings in Theoretical Computer Science</p>
</div>
<div class="citation" id="shen2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">Shen2004</a><span class="fn-bracket">]</span></span>
<p>V.V. Shende and S.S. Bullock and I.L. Markov, 2004. Synthesis of quantum-logic circuits. {IEEE} Transactions on Computer-Aided Design of Integrated Circuits and Systems</p>
</div>
<div class="citation" id="aaro2004" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">Aaro2004</a><span class="fn-bracket">]</span></span>
<p>Aaronson, S. and Gottesman, D., 2004. Improved Simulation of Stabilizer Circuits. Physical Review A, 70(5), p.052328.</p>
</div>
<div class="citation" id="brav2005" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">Brav2005</a><span class="fn-bracket">]</span></span>
<p>Bravyi, S. and Kitaev, A., 2005. Universal quantum computation with ideal Clifford gates and noisy ancillas. Physical Review A, 71(2), p.022316.</p>
</div>
<div class="citation" id="brav2012" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">Brav2012</a><span class="fn-bracket">]</span></span>
<p>Bravyi, S. and Haah, J., 2012. Magic-state distillation with low overhead. Physical Review A, 86(5), p.052329.</p>
</div>
<div class="citation" id="amy2014" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">Amy2014</a><span class="fn-bracket">]</span></span>
<p>Amy, M., Maslov, D. and Mosca, M., 2014. Polynomial-time T-depth optimization of Clifford+ T circuits via matroid partitioning. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 33(10), pp.1476-1489.</p>
</div>
<div class="citation" id="meij2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">Meij2020</a><span class="fn-bracket">]</span></span>
<p>de Griend, A.M.V. and Duncan, R., 2020. Architecture-aware synthesis of phase polynomials for NISQ devices. arXiv preprint arXiv:2004.06052.</p>
</div>
</div>
</section>
</section>
</section>


                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="manual_intro.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">What is tket?</p>
      </div>
    </a>
    <a class="right-next"
       href="manual_backend.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Running on Backends</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#basic-gates">Basic Gates</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#measurements">Measurements</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#barriers">Barriers</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#registers-and-ids">Registers and IDs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composing-circuits">Composing Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#statevectors-and-unitaries">Statevectors and Unitaries</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#analysing-circuits">Analysing Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#boxes">Boxes</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-boxes">Circuit Boxes</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boxes-for-unitary-synthesis">Boxes for Unitary Synthesis</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#controlled-box-operations">Controlled Box Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pauli-exponential-boxes-and-phase-polynommials">Pauli Exponential Boxes and Phase Polynommials</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiplexors-state-preperation-boxes-and-toffolibox">Multiplexors, State Preperation Boxes and <code class="xref py py-class docutils literal notranslate"><span class="pre">ToffoliBox</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#importing-exporting-circuits">Importing/Exporting Circuits</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#symbolic-circuits">Symbolic Circuits</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#symbolic-unitaries-and-states">Symbolic unitaries and states</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-topics">Advanced Topics</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#custom-parameterised-gates">Custom parameterised Gates</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#clifford-tableaux">Clifford Tableaux</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#classical-and-conditional-operations">Classical and conditional operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#circuit-level-operations">Circuit-Level Operations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">Implicit Qubit Permutations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#modifying-operations-within-circuits">Modifying Operations Within Circuits</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Cambridge Quantum Computing Ltd
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2020-2023 Cambridge Quantum Computing Ltd.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>