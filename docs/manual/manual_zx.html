

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>ZX Diagrams &#8212; pytket user manual</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/jupyter-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="_static/thebelab.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/thebelab-helper.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'manual_zx';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Assertion" href="manual_assertion.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
    
    
      
    
    
    <img src="_static/Quantinuum_logo_black.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="_static/Quantinuum_logo_white.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Manual Sections:</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="manual_intro.html">What is tket?</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_circuit.html">Circuit Construction</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_backend.html">Running on Backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_compiler.html">Compilation</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_noise.html">Noise and the Quantum Circuit Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual_assertion.html">Assertion</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">ZX Diagrams</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">More Documentation:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://cqcl.github.io/tket/pytket/api/">pytket</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cqcl.github.io/pytket-extensions/api/index.html">Extensions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/CQCL/pytket/tree/main/examples">Example notebooks</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/CQCL/tket" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/CQCL/tket/issues/new?title=Issue%20on%20page%20%2Fmanual_zx.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/manual_zx.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>ZX Diagrams</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#generator-types">Generator Types</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-diagrams">Creating Diagrams</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tensor-evaluation">Tensor Evaluation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-traversal-inspection-and-manual-rewriting">Graph Traversal, Inspection, and Manual Rewriting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#built-in-rewrite-passes">Built-in Rewrite Passes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mbqc-flow-detection">MBQC Flow Detection</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conversions-extraction">Conversions &amp; Extraction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compiler-passes-using-zx">Compiler Passes Using ZX</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-topics">Advanced Topics</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#c-implementation">C++ Implementation</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="zx-diagrams">
<h1>ZX Diagrams<a class="headerlink" href="#zx-diagrams" title="Permalink to this heading">#</a></h1>
<p>Aside from optimisation methods focussed on localised sequences of gates, the ZX-calculus has shown itself to be a useful representation for quantum operations that can highlight and exploit some specific kinds of higher-level redundancy in the structure of the circuit. In this section, we will assume the reader is familiar with the theory of ZX-calculus in terms of how to construct diagrams, apply rewrites to them, and interpret them as linear maps. We will focus on how to make use of the ZX module in <code class="docutils literal notranslate"><span class="pre">pytket</span></code> to help automate and scale your ideas. For a comprehensive introduction to the theory, we recommend reading van de Wetering’s overview paper <a class="reference internal" href="#vdwet2020" id="id1"><span>[vdWet2020]</span></a> or taking a look at the resources available at <a class="reference external" href="https://zxcalculus.com">zxcalculus.com</a>.</p>
<p>The graph representation used in the ZX module is intended to be sufficiently generalised to support experimentation with other graphical calculi like ZH, algebraic ZX, and MBQC patterns. This includes:</p>
<ul class="simple">
<li><p>Port annotations on edges to differentiate between multiple incident edges on a vertex for asymmetric generators such as subdiagram abstractions (<code class="xref py py-class docutils literal notranslate"><span class="pre">ZXBox</span></code>) or the triangle generator of algebraic ZX.</p></li>
<li><p>Structured generators for varied parameterisations, such as continuous real parameters of ZX spiders and discrete (Boolean) parameters of specialised Clifford generators.</p></li>
<li><p>Mixed quantum-classical diagram support via annotating edges and some generators with <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> for doubled diagrams (shorthand notation for a pair of adjoint edges/generators) or <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> for the singular variants (sometimes referred to as decoherent/bastard generators).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Providing this flexibility comes at the expense of some efficiency in both memory and speed of operations. For data structures more focussed on the core ZX-calculus and its well-developed simplification strategies, we recommend checking out <code class="docutils literal notranslate"><span class="pre">pyzx</span></code> (<a class="github reference external" href="https://github.com/Quantomatic/pyzx">Quantomatic/pyzx</a>) and its Rust port <code class="docutils literal notranslate"><span class="pre">quizx</span></code> (<a class="github reference external" href="https://github.com/Quantomatic/quizx">Quantomatic/quizx</a>). Some functionality for interoperation between <code class="docutils literal notranslate"><span class="pre">pytket</span></code> and <code class="docutils literal notranslate"><span class="pre">pyzx</span></code> circuits is provided in the <code class="docutils literal notranslate"><span class="pre">pytket-pyzx</span></code> extension package. There is no intention to support non-qubit calculi or SZX scalable notation in the near future as the additional complexity required by the data structure would introduce excessive bureaucracy to maintain during every rewrite.</p>
</div>
<section id="generator-types">
<h2>Generator Types<a class="headerlink" href="#generator-types" title="Permalink to this heading">#</a></h2>
<p>Before we start building diagrams, it is useful to cover the kinds of generators we can populate them with. A full list and details can be found in the API reference.</p>
<ul class="simple">
<li><p>Boundary generators: <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Input</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Output</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Open</span></code>. These are used to turn some edges of the diagram into half-edges, indicating the input, output, or unspecified boundaries of the diagram. These will be maintained in an ordered list in a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> to specify the intended order of indices when interpreting the diagram as a tensor.</p></li>
<li><p>Symmetric ZXH generators: <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.XSpider</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.HBox</span></code>. These are the familiar generators from standard literature. All incident edges are exchangeable, so no port information is used (all edges attach at port <code class="docutils literal notranslate"><span class="pre">None</span></code>). The degenerate <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> variants support both <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> incident edges, with the latter being treated as two distinct edges.</p></li>
<li><p>MBQC generators: <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.XY</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.XZ</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.YZ</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PX</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PY</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PZ</span></code>. These represent qubits in a measurement pattern that are postselected into the correct outcome (i.e. we do not consider errors and corrections as these can be inferred by flow detection). Each of them can be thought of as shorthand for a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code> with an adjacent spider indicating the postselection projector. The different types indicate either planar measurements with a continuous-parameter angle or a Pauli measurement with a Boolean angle selecting which outcome is the intended. Entanglement between qubits can be established with a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType.H</span></code> edge between vertices, with <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType.Basic</span></code> edges connecting to a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Input</span></code> to indicate input qubits. Unmeasured output qubits can be indicated using a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PX</span></code> vertex (essentially a zero phase <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code>) attached to a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Output</span></code>.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZXBox</span></code>. Similar to the concept of a <code class="xref py py-class docutils literal notranslate"><span class="pre">CircBox</span></code> for circuits, a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXBox</span></code> contains another <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> abstracted away which can later be expanded in-place. The ports and <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> of incident edges will align with the indices and types of the boundaries on the inner diagram.</p></li>
</ul>
<p>Each generator in a diagram is described by a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGen</span></code> object, or rather an object of one of its concrete subtypes depending on the data needed to describe the generator.</p>
</section>
<section id="creating-diagrams">
<h2>Creating Diagrams<a class="headerlink" href="#creating-diagrams" title="Permalink to this heading">#</a></h2>
<p>Let’s start by making the standard diagram for the qubit teleportation algorithm to showcase the capacity for mixed quantum-classical diagrams. Assuming that the Bell pair will be written in as initialised ancillae rather than open inputs, we just need to start with a diagram with just one quantum input and one quantum output.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pytket</span>
<span class="kn">from</span> <span class="nn">pytket.zx</span> <span class="kn">import</span> <span class="n">ZXDiagram</span><span class="p">,</span> <span class="n">ZXType</span><span class="p">,</span> <span class="n">QuantumType</span><span class="p">,</span> <span class="n">ZXWireType</span>
<span class="kn">import</span> <span class="nn">graphviz</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">tele</span> <span class="o">=</span> <span class="n">ZXDiagram</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_0_0.svg" src="_images/manual_zx_0_0.svg" /></div>
</div>
<p>We will choose to represent the Bell state as a cup (i.e. an edge connecting one side of the CX to the first correction). In terms of vertices, we need two for the CX gate, two for the measurements, and four for the encoding and application of corrections. The CX and corrections need to be coherent operations so will be <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> as opposed to the measurements and encodings. We can then link them up by adding edges of the appropriate <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code>. The visualisations will show <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> generators and edges with thick lines and <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> with thinner lines as per standard notation conventions.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in_v</span><span class="p">,</span> <span class="n">out_v</span><span class="p">)</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">()</span>
<span class="n">cx_c</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">cx_t</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">z_meas</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">x_meas</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">z_enc</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">x_enc</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">z_correct</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">x_correct</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>

<span class="c1"># Bell pair between CX and first correction</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_t</span><span class="p">,</span> <span class="n">x_correct</span><span class="p">)</span>

<span class="c1"># Apply CX between input and first ancilla</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">in_v</span><span class="p">,</span> <span class="n">cx_c</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_c</span><span class="p">,</span> <span class="n">cx_t</span><span class="p">)</span>

<span class="c1"># Measure first two qubits</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_c</span><span class="p">,</span> <span class="n">x_meas</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_t</span><span class="p">,</span> <span class="n">z_meas</span><span class="p">)</span>

<span class="c1"># Feed measurement outcomes to corrections</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">x_meas</span><span class="p">,</span> <span class="n">x_enc</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">x_enc</span><span class="p">,</span> <span class="n">z_correct</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">z_meas</span><span class="p">,</span> <span class="n">z_enc</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">z_enc</span><span class="p">,</span> <span class="n">x_correct</span><span class="p">)</span>

<span class="c1"># Apply corrections to second ancilla</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">x_correct</span><span class="p">,</span> <span class="n">z_correct</span><span class="p">)</span>
<span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">z_correct</span><span class="p">,</span> <span class="n">out_v</span><span class="p">)</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_1_0.svg" src="_images/manual_zx_1_0.svg" /></div>
</div>
<p>We can use this teleportation algorithm as a component in a larger diagram using a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXBox</span></code>. Here, we insert it in the middle of a two qubit circuit.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circ_diag</span> <span class="o">=</span> <span class="n">ZXDiagram</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">qin0</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Input</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">qin1</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Input</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">qout</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Output</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">cout</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Output</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">cz_c</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">cz_t</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="c1"># Phases of spiders are given in half-turns, so this is a pi/4 rotation</span>
<span class="n">rx</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">x_meas</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>
<span class="n">box</span> <span class="o">=</span> <span class="n">circ_diag</span><span class="o">.</span><span class="n">add_zxbox</span><span class="p">(</span><span class="n">tele</span><span class="p">)</span>

<span class="c1"># CZ between inputs</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">qin0</span><span class="p">,</span> <span class="n">cz_c</span><span class="p">)</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">qin1</span><span class="p">,</span> <span class="n">cz_t</span><span class="p">)</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cz_c</span><span class="p">,</span> <span class="n">cz_t</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

<span class="c1"># Rx on first qubit</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cz_c</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span>

<span class="c1"># Teleport first qubit</span>
<span class="c1"># The inputs appear first in the boundary of tele, so port 0 is the input</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">rx</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">v_port</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Port 1 for the output</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">u</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">qout</span><span class="p">,</span> <span class="n">u_port</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Measure second qubit destructively and output result</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cz_t</span><span class="p">,</span> <span class="n">x_meas</span><span class="p">)</span>
<span class="n">circ_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">x_meas</span><span class="p">,</span> <span class="n">cout</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">qtype</span><span class="o">=</span><span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span><span class="p">)</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">circ_diag</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_2_0.svg" src="_images/manual_zx_2_0.svg" /></div>
</div>
<p>As the entire graph data structure is exposed, it is very easy to construct objects that cannot be interpreted as a valid diagram. This is to be expected from intermediate states during the construction of a diagram or in the middle of applying a rewrite, before the state is returned to something sensible. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.check_validity()</span></code> method will perform a number of sanity checks on a given diagram object and it will raise an exception if any of them fail. We recommend using this during debugging to check that the diagram is not left in an invalid state. A diagram is deemed valid if it satisfies each of the following:</p>
<ul class="simple">
<li><p>Any vertex with of a boundary type (<code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Input</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Output</span></code>, or <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Open</span></code>) must have degree 1 (they uniquely identify a single edge as open) and exist in the boundary list.</p></li>
<li><p>Undirected vertices (those without port information, such as <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code>, or <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.HBox</span></code>) have no port annotations on incident edges.</p></li>
<li><p>Directed vertices (such as <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Triangle</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZXBox</span></code>) have exactly one incident edge at each port.</p></li>
<li><p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> of each edge is compatible with the vertices and ports they attach to. For example, a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code> with <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> requires all incident edges to also have <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code>, whereas a <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> vertex accepts any edge, and for a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZXBox</span></code> the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> of an edge must match the signature at the corresponding port.</p></li>
</ul>
</section>
<section id="tensor-evaluation">
<h2>Tensor Evaluation<a class="headerlink" href="#tensor-evaluation" title="Permalink to this heading">#</a></h2>
<p>Evaluating a diagram as a tensor is beneficial for practical use cases in scalar diagram evaluation (e.g. as part of expectation value calculations or simulation tasks), or for verification of correctness of diagram designs or rewrites. Evaluation is performed by building a tensor network out of the definitions of the generators and using a contraction strategy to reduce it down to a single tensor. Each diagram carries a global scalar which is multiplied into the tensor.</p>
<p>As the pytket ZX diagrams represent mixed diagrams, this impacts the interpretation of the tensors. Traditionally, we expect each edge of a ZX diagram to have dimension 2. This is the case for <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> edges, but since <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> edges represent a pair via doubling, they instead have dimension 4. The convention set by density matrix notation is to split this into two different indices, so <code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor_from_mixed_diagram()</span></code> will first expand the doubling notation in the diagram explicitly to give a diagram with only <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> edges and then evaluate it, meaning there will be an index for each original <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> edge and a new one for its conjugate. In particular, this will increase the number of boundary edges and therefore the expected rank of the overall tensor. The ordering of the indices will primarily follow the boundary order in the original diagram, subordered by doubling index for each <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> boundary as in the following example.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx.tensor_eval</span> <span class="kn">import</span> <span class="n">tensor_from_mixed_diagram</span>
<span class="n">ten</span> <span class="o">=</span> <span class="n">tensor_from_mixed_diagram</span><span class="p">(</span><span class="n">circ_diag</span><span class="p">)</span>
<span class="c1"># Indices are (qin0, qin0_conj, qin1, qin1_conj, qout, qout_conj, cout)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ten</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ten</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>(2, 2, 2, 2, 2, 2, 2)
[[[ 0.1509-0.j      0.1509-0.j    ]
  [-0.    -0.0625j -0.    -0.0625j]]

 [[ 0.    +0.0625j  0.    +0.0625j]
  [ 0.0259-0.j      0.0259-0.j    ]]]
</pre></div>
</div>
</div>
</div>
<p>In many cases, we work with pure quantum diagrams. This doubling would cause substantial blowup in time and memory for evaluation, as well as making the tensor difficult to navigate for large diagrams. <code class="xref py py-meth docutils literal notranslate"><span class="pre">tensor_from_quantum_diagram()</span></code> achieves the same as converting all <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> components to <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code>, meaning every edge is reduced down to dimension 2. Since the global scalar is maintained with respect to a doubled diagram, its square root is incorporated into the tensor, though we do not maintain the coherent global phase of a pure quantum diagram in this way. For diagrams like this, <code class="xref py py-meth docutils literal notranslate"><span class="pre">unitary_from_quantum_diagram()</span></code> reformats the tensor into the conventional unitary (with big-endian indexing).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx.tensor_eval</span> <span class="kn">import</span> <span class="n">tensor_from_quantum_diagram</span><span class="p">,</span> <span class="n">unitary_from_quantum_diagram</span>
<span class="n">u_diag</span> <span class="o">=</span> <span class="n">ZXDiagram</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">u_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Input</span><span class="p">)</span>
<span class="n">outs</span> <span class="o">=</span> <span class="n">u_diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Output</span><span class="p">)</span>
<span class="n">cx_c</span> <span class="o">=</span> <span class="n">u_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">cx_t</span> <span class="o">=</span> <span class="n">u_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">rz</span> <span class="o">=</span> <span class="n">u_diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">)</span>

<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cx_c</span><span class="p">)</span>
<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cx_t</span><span class="p">)</span>
<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_c</span><span class="p">,</span> <span class="n">cx_t</span><span class="p">)</span>
<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_t</span><span class="p">,</span> <span class="n">rz</span><span class="p">)</span>
<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">cx_c</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">u_diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">rz</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">tensor_from_quantum_diagram</span><span class="p">(</span><span class="n">u_diag</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unitary_from_quantum_diagram</span><span class="p">(</span><span class="n">u_diag</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[[[0.7071+0.j  0.    +0.j ]
   [0.    +0.j  0.    +0.j ]]

  [[0.    +0.j  0.5   -0.5j]
   [0.    +0.j  0.    +0.j ]]]


 [[[0.    +0.j  0.    +0.j ]
   [0.    +0.j  0.5   -0.5j]]

  [[0.    +0.j  0.    +0.j ]
   [0.7071+0.j  0.    +0.j ]]]]
[[0.7071+0.j  0.    +0.j  0.    +0.j  0.    +0.j ]
 [0.    +0.j  0.5   -0.5j 0.    +0.j  0.    +0.j ]
 [0.    +0.j  0.    +0.j  0.    +0.j  0.7071+0.j ]
 [0.    +0.j  0.    +0.j  0.5   -0.5j 0.    +0.j ]]
</pre></div>
</div>
</div>
</div>
<p>Similarly, one may use <code class="xref py py-meth docutils literal notranslate"><span class="pre">density_matrix_from_cptp_diagram()</span></code> to obtain a density matrix when all boundaries are <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Quantum</span></code> but the diagram itself contains mixed components. When input boundaries exist, this gives the density matrix under the Choi-Jamiołkovski isomorphism. For example, we can verify that our teleportation diagram from earlier really does reduce to the identity (recall that the Choi-Jamiołkovski isomorphism maps the identity channel to a Bell state).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx.tensor_eval</span> <span class="kn">import</span> <span class="n">density_matrix_from_cptp_diagram</span>

<span class="nb">print</span><span class="p">(</span><span class="n">density_matrix_from_cptp_diagram</span><span class="p">(</span><span class="n">tele</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[0.25+0.j 0.  +0.j 0.  +0.j 0.25+0.j]
 [0.  +0.j 0.  +0.j 0.  +0.j 0.  +0.j]
 [0.  +0.j 0.  +0.j 0.  +0.j 0.  +0.j]
 [0.25+0.j 0.  +0.j 0.  +0.j 0.25+0.j]]
</pre></div>
</div>
</div>
</div>
<p>Another way to potentially reduce the computational load for tensor evaluation is to fix basis states at the boundary vertices, corresponding to initialising inputs or post-selecting on outputs. There are utility methods for setting all inputs/outputs or specific boundary vertices to Z-basis states. For example, we can recover statevector simulation of a quantum circuit by setting all inputs to the zero state and calling <code class="xref py py-meth docutils literal notranslate"><span class="pre">unitary_from_quantum_diagram()</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx.tensor_eval</span> <span class="kn">import</span> <span class="n">fix_inputs_to_binary_state</span>
<span class="n">state_diag</span> <span class="o">=</span> <span class="n">fix_inputs_to_binary_state</span><span class="p">(</span><span class="n">u_diag</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unitary_from_quantum_diagram</span><span class="p">(</span><span class="n">state_diag</span><span class="p">)</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[[0. +0.j ]
 [0. +0.j ]
 [0. +0.j ]
 [0.5-0.5j]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="graph-traversal-inspection-and-manual-rewriting">
<h2>Graph Traversal, Inspection, and Manual Rewriting<a class="headerlink" href="#graph-traversal-inspection-and-manual-rewriting" title="Permalink to this heading">#</a></h2>
<p>The ability to build static diagrams is fine for visualisation and simulation needs, but the bulk of interest in graphical calculi is in rewriting for simplification. For this, it is enough to traverse the graph to search for relevant subgraphs and manipulate the graph in place. We will illustrate this by gradually rewriting the teleportation diagram to be the identity.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_7_0.svg" src="_images/manual_zx_7_0.svg" /></div>
</div>
<p>The boundary vertices offer a useful starting point for traversals. Each <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> maintains an ordered list of its boundaries to help distinguish them (note that this is different from the <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> system used by <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> objects), which we can retrieve with <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get_boundary()</span></code>. Each boundary vertex should have a unique incident edge which we can access through <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.adj_wires()</span></code>.</p>
<p>Once we have an edge, we can inspect and modify its properties, specifically its <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> with <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get/set_wire_qtype()</span></code> (whether it represents a single wire or a pair of wires under the doubling construction) and <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType</span></code> with <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get/set_wire_type()</span></code> (whether it is equivalent to an identity process or a Hadamard gate). To change the end points of a wire (even just moving it to another port on the same vertex), it is conventional to remove it and create a new wire.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">in_v</span><span class="p">,</span> <span class="n">out_v</span><span class="p">)</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">()</span>
<span class="n">in_edge</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">adj_wires</span><span class="p">(</span><span class="n">in_v</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">get_wire_qtype</span><span class="p">(</span><span class="n">in_edge</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">in_edge</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>QuantumType.Quantum
ZXWireType.Basic
</pre></div>
</div>
</div>
</div>
<p>The diagram is presented as an undirected graph. We can inspect the end points of an edge with <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get_wire_ends()</span></code>, which returns pairs of vertex and port. If we simply wish to traverse the edge to the next vertex, we use <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.other_end()</span></code>. Or we can skip wire traversal altogether using <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.neighbours()</span></code> to enumerate the neighbours of a given vertex. This is mostly useful when the wires in a diagram have a consistent form, such as in a graphlike or MBQC diagram (every wire is a Hadamard except for boundary wires).</p>
<p>If you are searching the diagram for a pattern that is simple enough that a full traversal would be excessive, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram.vertices</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram.wires</span></code> return lists of all vertices or edges in the diagram at that moment (in a deterministic but not semantically relevant order) which you can iterate over to search the graph quickly. Be aware that inserting or removing components of the diagram during iteration will not update these lists.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cx_c</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">in_edge</span><span class="p">,</span> <span class="n">in_v</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_ends</span><span class="p">(</span><span class="n">in_edge</span><span class="p">)</span> <span class="o">==</span> <span class="p">((</span><span class="n">in_v</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="n">cx_c</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>ZXType.Input
ZXType.Output
ZXType.ZSpider
ZXType.XSpider
ZXType.ZSpider
ZXType.XSpider
ZXType.ZSpider
ZXType.XSpider
ZXType.ZSpider
ZXType.XSpider
</pre></div>
</div>
</div>
</div>
<p>Using this, we can scan our diagram for adjacent spiders of the same colour connected by a basic edge to apply spider fusion. In general, this will require us to also inspect the generators of the vertex to be able to add the phases and update the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> in case of merging with a <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType.Classical</span></code> spider.</p>
<p>Similar to edges, each vertex contains a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGen</span></code> object describing the particular generator it represents which we can retrieve using <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get_vertex_ZXGen()</span></code>. As each kind of generator has different data, when using a diagram with many kinds of generators it is useful to inspect the <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType</span></code> or the subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGen</span></code> first. For example, if <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.get_zxtype()</span></code> returns <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.ZSpider</span></code>, we know the generator is a <code class="xref py py-class docutils literal notranslate"><span class="pre">PhasedGen</span></code> and hence has the <code class="xref py py-class docutils literal notranslate"><span class="pre">PhasedGen.param</span></code> field describing the phase of the spider.</p>
<p>Each generator object is immutable, so updating a vertex requires creating a new <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGen</span></code> object with the desired properties and passing it to <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.set_vertex_ZXGen()</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx</span> <span class="kn">import</span> <span class="n">PhasedGen</span>

<span class="k">def</span> <span class="nf">fuse</span><span class="p">():</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">removed</span> <span class="ow">or</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">adj_wires</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">Basic</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">n</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">!=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Match found, copy n&#39;s edges onto v</span>
            <span class="k">for</span> <span class="n">nw</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">adj_wires</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nw</span> <span class="o">!=</span> <span class="n">w</span><span class="p">:</span>
                    <span class="c1"># We know all vertices here are symmetric generators so we</span>
                    <span class="c1"># don&#39;t need to care about port information</span>
                    <span class="n">nn</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">nw</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
                    <span class="n">wtype</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
                    <span class="n">qtype</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_qtype</span><span class="p">(</span><span class="n">nw</span><span class="p">)</span>
                    <span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">nn</span><span class="p">,</span> <span class="n">wtype</span><span class="p">,</span> <span class="n">qtype</span><span class="p">)</span>
            <span class="c1"># Update v to have total phase</span>
            <span class="n">n_spid</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_vertex_ZXGen</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">v_spid</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_vertex_ZXGen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">v_qtype</span> <span class="o">=</span> <span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span> <span class="k">if</span> <span class="n">n_spid</span><span class="o">.</span><span class="n">qtype</span> <span class="o">==</span> <span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span> <span class="ow">or</span> <span class="n">v_spid</span><span class="o">.</span><span class="n">qtype</span> <span class="o">==</span> <span class="n">QuantumType</span><span class="o">.</span><span class="n">Classical</span> <span class="k">else</span> <span class="n">QuantumType</span><span class="o">.</span><span class="n">Quantum</span>
            <span class="n">tele</span><span class="o">.</span><span class="n">set_vertex_ZXGen</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">PhasedGen</span><span class="p">(</span><span class="n">v_spid</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">v_spid</span><span class="o">.</span><span class="n">param</span> <span class="o">+</span> <span class="n">n_spid</span><span class="o">.</span><span class="n">param</span><span class="p">,</span> <span class="n">v_qtype</span><span class="p">))</span>
            <span class="c1"># Remove n</span>
            <span class="n">tele</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">removed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="n">fuse</span><span class="p">()</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_10_0.svg" src="_images/manual_zx_10_0.svg" /></div>
</div>
<p>Similarly, we can scan for a pair of adjacent basic edges between a green and a red spider for the strong complementarity rule.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">strong_comp</span><span class="p">():</span>
    <span class="n">gr_edges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">wires</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">Basic</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">u_port</span><span class="p">),</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v_port</span><span class="p">))</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_ends</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">gr_match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span> <span class="ow">and</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">:</span>
            <span class="n">gr_match</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span> <span class="ow">and</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">:</span>
            <span class="n">gr_match</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">gr_match</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gr_match</span> <span class="ow">in</span> <span class="n">gr_edges</span><span class="p">:</span>
                <span class="c1"># Found a matching pair, remove them</span>
                <span class="n">other_w</span> <span class="o">=</span> <span class="n">gr_edges</span><span class="p">[</span><span class="n">gr_match</span><span class="p">]</span>
                <span class="n">tele</span><span class="o">.</span><span class="n">remove_wire</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="n">tele</span><span class="o">.</span><span class="n">remove_wire</span><span class="p">(</span><span class="n">other_w</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">gr_edges</span><span class="p">[</span><span class="n">gr_match</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Record the edge for later</span>
                <span class="n">gr_edges</span><span class="p">[</span><span class="n">gr_match</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

<span class="n">strong_comp</span><span class="p">()</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_11_0.svg" src="_images/manual_zx_11_0.svg" /></div>
</div>
<p>Finally, we write a procedure that finds spiders of degree 2 which act like an identity. We need to check that the phase on the spider is zero, and that the <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> of the generator matches those of the incident edges (so we don’t accidentally remove decoherence spiders).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">id_remove</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">tele</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tele</span><span class="o">.</span><span class="n">degree</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_zxtype</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">):</span>
            <span class="n">spid</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_vertex_ZXGen</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">adj_wires</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">spid</span><span class="o">.</span><span class="n">param</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_qtype</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">spid</span><span class="o">.</span><span class="n">qtype</span> <span class="ow">and</span> <span class="n">tele</span><span class="o">.</span><span class="n">get_wire_qtype</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">spid</span><span class="o">.</span><span class="n">qtype</span><span class="p">:</span>
                <span class="c1"># Found an identity</span>
                <span class="n">n0</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">n1</span> <span class="o">=</span> <span class="n">tele</span><span class="o">.</span><span class="n">other_end</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">wtype</span> <span class="o">=</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span> <span class="k">if</span> <span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">get_wire_type</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span> <span class="k">else</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">Basic</span>
                <span class="n">tele</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">wtype</span><span class="p">,</span> <span class="n">spid</span><span class="o">.</span><span class="n">qtype</span><span class="p">)</span>
                <span class="n">tele</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

<span class="n">id_remove</span><span class="p">()</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_12_0.svg" src="_images/manual_zx_12_0.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fuse</span><span class="p">()</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_13_0.svg" src="_images/manual_zx_13_0.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">strong_comp</span><span class="p">()</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_14_0.svg" src="_images/manual_zx_14_0.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">id_remove</span><span class="p">()</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">tele</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_15_0.svg" src="_images/manual_zx_15_0.svg" /></div>
</div>
<p>A number of other methods for inspecting and traversing a diagram are available and can be found in the API reference.</p>
</section>
<section id="built-in-rewrite-passes">
<h2>Built-in Rewrite Passes<a class="headerlink" href="#built-in-rewrite-passes" title="Permalink to this heading">#</a></h2>
<p>The pytket ZX module comes with a handful of common rewrite procedures built-in to prevent the need to write manual traversals in many cases. These procedures work in a similar way to the pytket compilation passes in applying a particular strategy across the entire diagram, saving computational time by potentially applying many rewrites in a single traversal. In the cases where there are overlapping patterns or rewrites that introduce new target patterns in the output diagram, these rewrites may not always be applied exhaustively to save time backtracking.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This diagram follows from section A of https://arxiv.org/pdf/1902.03178.pdf</span>
<span class="n">diag</span> <span class="o">=</span> <span class="n">ZXDiagram</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">ins</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Input</span><span class="p">)</span>
<span class="n">outs</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Output</span><span class="p">)</span>
<span class="n">v11</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">v12</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">v13</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v14</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">v15</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">v21</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">v22</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v23</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v24</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="n">v25</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v31</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">v32</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">v33</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">v34</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">v35</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">)</span>
<span class="n">v41</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v42</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">)</span>
<span class="n">v43</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="n">v44</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">v45</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">ZSpider</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="n">v46</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">add_vertex</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">XSpider</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>

<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v11</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v11</span><span class="p">,</span> <span class="n">v12</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v12</span><span class="p">,</span> <span class="n">v13</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v13</span><span class="p">,</span> <span class="n">v41</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v13</span><span class="p">,</span> <span class="n">v14</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v14</span><span class="p">,</span> <span class="n">v42</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v14</span><span class="p">,</span> <span class="n">v15</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v15</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>

<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v21</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v21</span><span class="p">,</span> <span class="n">v22</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v22</span><span class="p">,</span> <span class="n">v31</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v22</span><span class="p">,</span> <span class="n">v23</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v23</span><span class="p">,</span> <span class="n">v32</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v23</span><span class="p">,</span> <span class="n">v24</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v24</span><span class="p">,</span> <span class="n">v25</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v25</span><span class="p">,</span> <span class="n">v35</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">outs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v25</span><span class="p">)</span>

<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v31</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v31</span><span class="p">,</span> <span class="n">v32</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v32</span><span class="p">,</span> <span class="n">v33</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v33</span><span class="p">,</span> <span class="n">v34</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v34</span><span class="p">,</span> <span class="n">v35</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v35</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">ins</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">v41</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v41</span><span class="p">,</span> <span class="n">v42</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v42</span><span class="p">,</span> <span class="n">v43</span><span class="p">,</span> <span class="n">ZXWireType</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v43</span><span class="p">,</span> <span class="n">v44</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v44</span><span class="p">,</span> <span class="n">v45</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v45</span><span class="p">,</span> <span class="n">v46</span><span class="p">)</span>
<span class="n">diag</span><span class="o">.</span><span class="n">add_wire</span><span class="p">(</span><span class="n">v46</span><span class="p">,</span> <span class="n">outs</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">diag</span><span class="o">.</span><span class="n">check_validity</span><span class="p">()</span>

<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_16_0.svg" src="_images/manual_zx_16_0.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx</span> <span class="kn">import</span> <span class="n">Rewrite</span>

<span class="n">Rewrite</span><span class="o">.</span><span class="n">red_to_green</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">Rewrite</span><span class="o">.</span><span class="n">spider_fusion</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">Rewrite</span><span class="o">.</span><span class="n">io_extension</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_17_0.svg" src="_images/manual_zx_17_0.svg" /></div>
</div>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Rewrite</span><span class="o">.</span><span class="n">reduce_graphlike_form</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_18_0.svg" src="_images/manual_zx_18_0.svg" /></div>
</div>
<p>The particular rewrites available are intended to support common optimisation strategies. In particular, they mostly focus on converting a diagram to graphlike form and working on graphlike diagrams to reduce the number of vertices as much as possible. These have close correspondences with MBQC patterns, and the rewrites preserve the existence of flow, which helps guarantee an efficient extraction procedure.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Because of the focus on strategies using graphlike diagrams, many of the rewrites expect the inputs to be of a particular form. This may cause some issues if you attempt to apply them to diagrams that aren’t in the intended form, especially when working with classical or mixed diagrams.</p>
</div>
<p>The rewrite passes can be broken down into a few categories depending on the form of the diagrams expected and the function of the passes. Full descriptions of each pass are given in the API reference.</p>
<table class="table">
<tbody>
<tr class="row-odd"><td><p>Decompositions into generating sets</p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.decompose_boxes()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.basic_wires()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.rebase_to_zx()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.rebase_to_mbqc()</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Rewriting into graphlike form</p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.red_to_green()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.spider_fusion()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.self_loop_removal()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.parallel_h_removal()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.separate_boundaries()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.io_extension()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Reduction within graphlike form</p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.remove_interior_cliffords()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.remove_interior_paulis()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.gadgetise_interior_paulis()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.merge_gadgets()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.extend_at_boundary_paulis()</span></code></p></td>
</tr>
<tr class="row-even"><td><p>MBQC</p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.extend_for_PX_outputs()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.internalise_gadgets()</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Composite sequences</p></td>
<td><p><code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.to_graphlike_form()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.reduce_graphlike_form()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.to_MBQC_diag()</span></code></p></td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Current implementations of rewrite passes may not track the global scalar. Semantics of diagrams is only preserved up to scalar. This is fine for simplification of states or unitaries as they can be renormalised but this may cause issues if attempting to use rewrites for scalar diagram evaluation.</p>
</div>
</section>
<section id="mbqc-flow-detection">
<h2>MBQC Flow Detection<a class="headerlink" href="#mbqc-flow-detection" title="Permalink to this heading">#</a></h2>
<p>So far, we have focussed mostly on the circuit model of quantum computing, but the ZX module is also geared towards assisting for MBQC. The most practical measurement patterns are those with uniform, stepwise, strong determinism - that is, performing an individual measurement and its associated corrections will yield exactly the same residual state, and furthermore this is the case for any choice of angle parameter the qubit is measured in (within a particular plane of the Bloch sphere or choice of polarity of a Pauli measurement, according to the label of the measurement). In this case, the order of measurements and corrections can be described by a Flow over the entanglement graph.</p>
<p>When using the ZX module to represent measurement patterns, we care about representing the semantics and so it is sufficient to consider post-selecting the intended branch outcome at each qubit. This simplifies the diagram by eliminating the corrections and any need to track the order of measurements internally to the diagram. Instead, we may track these externally using a <code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code> object.</p>
<p>Each of the MBQC <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType</span></code> options represent a qubit that is initialised and post-selected into the plane/Pauli specified by the type, at the angle/polarity given by the parameter of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGen</span></code>. Entanglement between these qubits is given by <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType.H</span></code> edges, representing CZ gates. We identify input and output qubits using <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType.Basic</span></code> edges connecting them to <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Input</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.Output</span></code> vertices (since output qubits are unmeasured, their semantics as tensors are equivalent to <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PX</span></code> vertices with <code class="docutils literal notranslate"><span class="pre">False</span></code> polarity). The <code class="xref py py-meth docutils literal notranslate"><span class="pre">Rewrite.to_MBQC_diag()</span></code> rewrite will transform any ZX diagram into one of this form.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Rewrite</span><span class="o">.</span><span class="n">to_MBQC_diag</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">gv</span><span class="o">.</span><span class="n">Source</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">to_graphviz_str</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/manual_zx_19_0.svg" src="_images/manual_zx_19_0.svg" /></div>
</div>
<p>Given a ZX diagram in MBQC form, there are algorithms that can find a suitable <code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code> if one exists. Since there are several classifications of flow (e.g. causal flow, gflow, Pauli flow, extended Pauli flow) with varying levels of generality, we offer multiple algorithms for identifying them. For example, any diagram supporting a uniform, stepwise, strongly deterministic measurement and correction scheme will have a Pauli flow, but identification of this is <span class="math notranslate nohighlight">\(O(n^4)\)</span> in the number of qubits (vertices) in the pattern. On the other hand, causal flow is a particular special case that may not always exist but can be identified in <span class="math notranslate nohighlight">\(O(n^2 \log n)\)</span> time.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code> object that is returned abstracts away the partial ordering of the measured qubits of the diagram by just giving the depth from the outputs, i.e. all output qubits and those with no corrections have depth <span class="math notranslate nohighlight">\(0\)</span>, all qubits with depth <span class="math notranslate nohighlight">\(n\)</span> can be measured simultaneously and only require corrections on qubits at depth strictly less than <span class="math notranslate nohighlight">\(n\)</span>. The measurement corrections can also be inferred from the flow, where <code class="xref py py-meth docutils literal notranslate"><span class="pre">Flow.c()</span></code> gives the correction set for a given measured qubit (the qubits which require an <span class="math notranslate nohighlight">\(X\)</span> correction if a measurement error occurs) and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Flow.odd()</span></code> gives its odd neighbourhood (the qubits which require a <span class="math notranslate nohighlight">\(Z\)</span> correction).</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.zx</span> <span class="kn">import</span> <span class="n">Flow</span>

<span class="n">fl</span> <span class="o">=</span> <span class="n">Flow</span><span class="o">.</span><span class="n">identify_pauli_flow</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>

<span class="c1"># We can look up the flow data for a particular vertex</span>
<span class="c1"># For example, let&#39;s take the first input qubit</span>
<span class="n">vertex_ids</span> <span class="o">=</span> <span class="p">{</span> <span class="n">v</span> <span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="p">}</span>
<span class="n">in0</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">get_boundary</span><span class="p">(</span><span class="n">ZXType</span><span class="o">.</span><span class="n">Input</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="n">in0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fl</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">print</span><span class="p">([</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">fl</span><span class="o">.</span><span class="n">c</span><span class="p">(</span><span class="n">v</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">([</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">o</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">fl</span><span class="o">.</span><span class="n">odd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">diag</span><span class="p">)])</span>

<span class="c1"># Or we can obtain the entire flow as maps for easy iteration</span>
<span class="nb">print</span><span class="p">({</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">:</span> <span class="n">d</span> <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fl</span><span class="o">.</span><span class="n">dmap</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">})</span>
<span class="nb">print</span><span class="p">({</span> <span class="n">vertex_ids</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="p">:</span> <span class="p">[</span><span class="n">vertex_ids</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cs</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cs</span><span class="p">)</span> <span class="ow">in</span> <span class="n">fl</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="p">})</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>8
2
[9]
[15, 8]
{8: 2, 9: 1, 17: 1, 10: 2, 16: 1, 11: 1, 15: 0, 12: 1, 22: 1, 14: 2, 21: 0, 20: 1, 13: 2, 18: 1, 19: 0, 23: 0}
{8: [9], 9: [15], 17: [22], 10: [12, 11], 16: [20], 11: [12, 16, 19, 21], 15: [], 12: [18], 22: [23], 14: [17, 9], 21: [], 20: [21], 13: [11], 18: [19], 19: [], 23: []}
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In accordance with the Pauli flow criteria, <code class="xref py py-meth docutils literal notranslate"><span class="pre">Flow.c()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">Flow.odd()</span></code> may return qubits that have already been measured, but this may only happen in cases where the required correction would not have affected the past measurement such as a <span class="math notranslate nohighlight">\(Z\)</span> on a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.PZ</span></code> qubit.</p>
</div>
<p>In general, multiple valid flows may exist for a given diagram, but a pattern with equal numbers of inputs and outputs will always have a unique focussed flow (where the corrections permitted on each qubit are restricted to be a single Pauli based on its label, e.g. if qubit <span class="math notranslate nohighlight">\(q\)</span> is labelled as <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXType.XY</span></code>, then we may only apply <span class="math notranslate nohighlight">\(X\)</span> corrections to <span class="math notranslate nohighlight">\(q\)</span>). Given any flow, we may transform it to a focussed flow using <code class="xref py py-meth docutils literal notranslate"><span class="pre">Flow.focus()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Flow</span></code> object is always with respect to a particular <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> in a particular state. It cannot be applied to other diagrams and does not automatically update on rewriting the diagram.</p>
</div>
</section>
<section id="conversions-extraction">
<h2>Conversions &amp; Extraction<a class="headerlink" href="#conversions-extraction" title="Permalink to this heading">#</a></h2>
<p>Up to this point, we have only examined the ZX module in a vacuum, so now we will look at integrating it with the rest of tket’s functionality by converting between <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> objects. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">circuit_to_zx()</span></code> function will reconstruct a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> as a <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> by replacing each gate with a choice of representation in the ZX-calculus.</p>
<p>The boundaries of the resulting <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> will match up with the open boundaries of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>. However, <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType.Create</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">OpType.Discard</span></code> operations will be replaced with an initialisation and a discard map respectively, meaning the number of boundary vertices in the resulting diagram may not match up with the number of qubits and bits in the original <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>. This makes it difficult to have a sensible policy for knowing where in the linear boundary of the <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> is the input/output of a particular qubit. The second return value of <code class="xref py py-meth docutils literal notranslate"><span class="pre">circuit_to_zx()</span></code> is a map sending a <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> to the pair of <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXVert</span></code> objects for the corresponding input and output.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">pytket.zx</span> <span class="kn">import</span> <span class="n">circuit_to_zx</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">CZ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">CX</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">Rz</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">X</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">H</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">qubit_create</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="n">c</span><span class="o">.</span><span class="n">qubit_discard</span><span class="p">(</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">diag</span><span class="p">,</span> <span class="n">bound_map</span> <span class="o">=</span> <span class="n">circuit_to_zx</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">in3</span><span class="p">,</span> <span class="n">out3</span> <span class="o">=</span> <span class="n">bound_map</span><span class="p">[</span><span class="n">Qubit</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="c1"># Qubit 3 was discarded, so out3 won&#39;t give a vertex</span>
<span class="c1"># Look at the neighbour of the input to check the first operation is the X</span>
<span class="n">n</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">neighbours</span><span class="p">(</span><span class="n">in3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">diag</span><span class="o">.</span><span class="n">get_vertex_ZXGen</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Q-X(1)
</pre></div>
</div>
</div>
</div>
<p>From here, we are able to rewrite our circuit as a ZX diagram, and even though we may aim to preserve the semantics, there is often little guarantee that the diagram will resemble the structure of a circuit after rewriting. The extraction problem concerns taking a ZX diagram and attempting to identify an equivalent circuit, and this is known to be #P-Hard for arbitrary diagrams equivalent to a unitary circuit which is not computationally feasible. However, if we can guarantee that our rewriting leaves us with a diagram in MBQC form which admits a flow of some kind, then there exist efficient methods for extracting an equivalent circuit.</p>
<p>The current method implemented in <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.to_circuit()</span></code> permits extraction of a circuit from a unitary ZX diagram with gflow, based on the method of Backens et al. <a class="reference internal" href="#back2021" id="id2"><span>[Back2021]</span></a>. More methods may be added in the future for different extraction methods, such as fast extraction with causal flow, MBQC (i.e. a <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code> with explicit measurement and correction operations), extraction from Pauli flow, and mixed diagram extraction.</p>
<p>Since the <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXDiagram</span></code> class does not associate a <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> to each boundary vertex, <code class="xref py py-meth docutils literal notranslate"><span class="pre">ZXDiagram.to_circuit()</span></code> also returns a map sending each boundary <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXVert</span></code> to the corresponding <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitID</span></code> in the resulting <code class="xref py py-class docutils literal notranslate"><span class="pre">Circuit</span></code>.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket</span> <span class="kn">import</span> <span class="n">OpType</span>
<span class="kn">from</span> <span class="nn">pytket.circuit.display</span> <span class="kn">import</span> <span class="n">render_circuit_jupyter</span>
<span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">auto_rebase_pass</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">CCX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">CCX</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">c</span><span class="o">.</span><span class="n">CCX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1"># Conversion is only defined for a subset of gate types - rebase as needed</span>
<span class="n">auto_rebase_pass</span><span class="p">({</span> <span class="n">OpType</span><span class="o">.</span><span class="n">Rx</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">Rz</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">H</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">CZ</span><span class="p">,</span> <span class="n">OpType</span><span class="o">.</span><span class="n">CX</span> <span class="p">})</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">diag</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">circuit_to_zx</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

<span class="n">Rewrite</span><span class="o">.</span><span class="n">to_graphlike_form</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">Rewrite</span><span class="o">.</span><span class="n">reduce_graphlike_form</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>

<span class="c1"># Extraction requires the diagram to use MBQC generators</span>
<span class="n">Rewrite</span><span class="o">.</span><span class="n">to_MBQC_diag</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
<span class="n">circ</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">diag</span><span class="o">.</span><span class="n">to_circuit</span><span class="p">()</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-992943fe-82cc-4bf7-b893-10feaf568bd4&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1.75&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], [[&#34;q&#34;, [3]], [&#34;q&#34;, [2]]], [[&#34;q&#34;, [4]], [&#34;q&#34;, [0]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]], [&#34;q&#34;, [3]], [&#34;q&#34;, [4]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;992943fe-82cc-4bf7-b893-10feaf568bd4&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
</section>
<section id="compiler-passes-using-zx">
<h2>Compiler Passes Using ZX<a class="headerlink" href="#compiler-passes-using-zx" title="Permalink to this heading">#</a></h2>
<p>The known methods for circuit rewriting and optimisation lend themselves to a single common routine of mapping to graphlike form, reducing within that form, and extracting back out. <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGraphlikeOptimisation</span></code> is a standard pytket compiler pass that packages this routine up for convenience to save the user from manually digging into the ZX module before they can test out using the compilation routine on their circuits.</p>
<div class="jupyter_cell jupyter_container docutils container">
<div class="cell_input code_cell docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytket.passes</span> <span class="kn">import</span> <span class="n">ZXGraphlikeOptimisation</span>

<span class="c1"># Use the same CCX example from above</span>
<span class="n">ZXGraphlikeOptimisation</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">render_circuit_jupyter</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html">





<div style="resize: vertical; overflow: auto; height: 400px; display: block">
    <iframe srcdoc="
&lt;!DOCTYPE html&gt;
&lt;html lang=&#34;en&#34;&gt;
&lt;head&gt;
    &lt;meta charset=&#34;UTF-8&#34;&gt;
    &lt;!-- Download Vue 3--&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://cdn.jsdelivr.net/npm/vue@3&#34;&gt;&lt;/script&gt;
&lt;!-- Download Circuit Renderer with styles --&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.umd.js&#34;&gt;&lt;/script&gt;
&lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/pytket-circuit-renderer@0.6/dist/pytket-circuit-renderer.css&#34;&gt;
&lt;/head&gt;
&lt;body&gt;



    &lt;div id=&#34;circuit-display-vue-container-1d8e4d41-e355-4b26-a4f4-1b48b833745e&#34; class=&#34;pytket-circuit-display-container&#34;&gt;
        &lt;div style=&#34;display: none&#34;&gt;
            &lt;div id=&#34;circuit-json-to-display&#34;&gt;{&#34;bits&#34;: [], &#34;commands&#34;: [{&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1.75&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [2]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [3]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;params&#34;: [&#34;0.25&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]], [&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;CX&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;params&#34;: [&#34;-1/4&#34;], &#34;type&#34;: &#34;U1&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [4]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [1]], [&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;CZ&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}, {&#34;args&#34;: [[&#34;q&#34;, [0]]], &#34;op&#34;: {&#34;type&#34;: &#34;H&#34;}}], &#34;created_qubits&#34;: [], &#34;discarded_qubits&#34;: [], &#34;implicit_permutation&#34;: [[[&#34;q&#34;, [0]], [&#34;q&#34;, [1]]], [[&#34;q&#34;, [1]], [&#34;q&#34;, [4]]], [[&#34;q&#34;, [2]], [&#34;q&#34;, [3]]], [[&#34;q&#34;, [3]], [&#34;q&#34;, [2]]], [[&#34;q&#34;, [4]], [&#34;q&#34;, [0]]]], &#34;phase&#34;: &#34;0.0&#34;, &#34;qubits&#34;: [[&#34;q&#34;, [0]], [&#34;q&#34;, [1]], [&#34;q&#34;, [2]], [&#34;q&#34;, [3]], [&#34;q&#34;, [4]]]}&lt;/div&gt;
        &lt;/div&gt;
        &lt;circuit-display-container
                :circuit-element-str=&#34;&#39;#circuit-json-to-display&#39;&#34;
                :init-render-options=&#34;initRenderOptions&#34;
        &gt;&lt;/circuit-display-container&gt;
    &lt;/div&gt;
    &lt;script type=&#34;application/javascript&#34;&gt;
      const circuitRendererUid = &#34;1d8e4d41-e355-4b26-a4f4-1b48b833745e&#34;;
      const displayOptions = JSON.parse(&#39;{}&#39;);

      // Script to initialise the circuit renderer app

const { createApp } = Vue;
const circuitDisplayContainer = window[&#34;pytket-circuit-renderer&#34;].default;
// Init variables to be shared between circuit display instances
if (typeof window.pytketCircuitDisplays === &#34;undefined&#34;) {
    window.pytketCircuitDisplays = {};
}
// Create the root Vue component
const app = createApp({
    delimiters: [&#39;[[#&#39;, &#39;#]]&#39;],
    components: { circuitDisplayContainer },
    data () {
      return {
        initRenderOptions: displayOptions,
      }
    }
})
app.config.unwrapInjectedRef = true;
app.mount(&#34;#circuit-display-vue-container-&#34;+circuitRendererUid);
window.pytketCircuitDisplays[circuitRendererUid] = app;
    &lt;/script&gt;



&lt;/body&gt;
&lt;/html&gt;
"
            width="100%" height="100%"
            style="border: none; outline: none; overflow: auto"></iframe>
</div>

</div></div>
</div>
<p>The specific nature of optimising circuits via ZX diagrams gives rise to some general advice regarding how to use <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGraphlikeOptimisation</span></code> in compilation sequences and what to expect from its performance:</p>
<ul class="simple">
<li><p>The routine can broadly be thought of as a resynthesis pass: converting to a graphlike ZX diagram completely abstracts away most of the circuit structure and attempts to extract a new circuit from scratch. Coupling this with the difficulty of optimal extraction means that if the original circuit is already well-structured or close to optimal, it is likely that the process of forgetting that structure and trying to extract something new will increase gate counts. Since the graphlike form abstracts away the structure from Clifford gates to focus on the non-Cliffords, it is most likely going to give its best results on very Clifford-dense circuits. Even in cases where this improves on gate counts, it may be the case that the new circuit structure is harder to efficiently route on a device with restricted qubit connectivity, so it is important to consider the context of a full compilation sequence when analysing the benefits of using this routine.</p></li>
</ul>
<ul class="simple">
<li><p>Similarly, because the conversion to a graphlike ZX diagram completely abstracts away the Clifford gates, there is often little-to-no benefit in running most simple optimisations before applying <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXGraphlikeOptimisation</span></code> since it will largely ignore them and achieve the same graphlike form regardless.</p></li>
</ul>
<ul class="simple">
<li><p>The implementation of the extraction routine in pytket follows the steps from Backens et al. <a class="reference internal" href="#back2021" id="id3"><span>[Back2021]</span></a> very closely without optimising the gate sequences as they are produced. It is recommended to run additional peephole optimisation passes afterwards to account for redundancies introduced by the extraction procedure. For example, we can see in the above example that there are many sequences of successive Hadamard gates that could be removed using a pass like <code class="xref py py-class docutils literal notranslate"><span class="pre">RemoveRedundancies</span></code>. <code class="xref py py-class docutils literal notranslate"><span class="pre">FullPeepholeOptimise</span></code> is a good catch-all that incorporates many peephole optimisations and could further reduce the extracted circuit.</p></li>
</ul>
</section>
<section id="advanced-topics">
<h2>Advanced Topics<a class="headerlink" href="#advanced-topics" title="Permalink to this heading">#</a></h2>
<section id="c-implementation">
<h3>C++ Implementation<a class="headerlink" href="#c-implementation" title="Permalink to this heading">#</a></h3>
<p>As with the rest of pytket, the ZX module features a python interface that has enough flexibility to realise any diagram a user would wish to construct or a rewrite they would like to apply, but the data structure itself is defined in the core C++ library for greater speed for longer rewrite passes and analysis tasks. This comes with the downside that interacting via the python interface is slowed down by the need to convert data through the bindings. After experimenting with the python interface and devising new rewrite strategies, we recommend users use the C++ library directly for speed and greater control over the data structure when attempting to write heavy-duty implementations that require the use of this module’s unique features (for simpler rewriting tasks, it may be faster to use <code class="docutils literal notranslate"><span class="pre">quizx</span></code> [<a class="github reference external" href="https://github.com/Quantomatic/quizx">Quantomatic/quizx</a>] which sacrifices some flexibility for even more performance).</p>
<p>The interface to the <code class="docutils literal notranslate"><span class="pre">ZXDiagram</span></code> C++ class is extremely similar to the python interface. The main difference is that, whilst the edges of a ZX diagram are semantically undirected, the underlying data structure for the graph itself uses directed edges. This allows us to attach the port data for an edge to the edge metadata and distinguish between its two end-points by referring to the source and target of the edge - for example, an edge between <span class="math notranslate nohighlight">\((u,1)\)</span> and <span class="math notranslate nohighlight">\((v,-)\)</span> (where <span class="math notranslate nohighlight">\(v\)</span> is a symmetric generator without port information) can be represented as an edge from <span class="math notranslate nohighlight">\(u\)</span> to <span class="math notranslate nohighlight">\(v\)</span> whose metadata carries <code class="docutils literal notranslate"><span class="pre">(source_port</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">target_port</span> <span class="pre">=</span> <span class="pre">std::nullopt)</span></code>.</p>
<p>When implementing a rewrite in C++, we recommend exposing your method via the pybind interface and testing it using pytket when possible. The primary reason for this is that the tensor evaluation available uses the <code class="docutils literal notranslate"><span class="pre">quimb</span></code> python package to scale to large numbers of nodes in the tensor network, which is particularly useful for testing that your rewrite preserves the diagram semantics.</p>
<p>In place of API reference and code examples, we recommend looking at the following parts of the tket source code to see how the ZX module is already used:</p>
<ul class="simple">
<li><p>ZXDiagram.hpp gives inline summaries for the interface to the core diagram data structure.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rewrite::spider_fusion_fun()</span></code> in ZXRWAxioms.cpp is an example of a simple rewrite that is applied across the entire graph by iterating over each vertex and looking for patterns in its immediate neighbourhood. It demonstrates the relevance of checking edge data for its <code class="xref py py-class docutils literal notranslate"><span class="pre">ZXWireType</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">QuantumType</span></code> and maintaining track of these throughout a rewrite.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rewrite::remove_interior_paulis_fun()</span></code> in ZXRWGraphLikeSimplification.cpp demonstrates how the checks and management of the format of vertices and edges can be simplified a little once it is established that the diagram is of a particular form (e.g. graphlike).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ZXGraphlikeOptimisation()</span></code> in PassLibrary.cpp uses a sequence of rewrites along with the converters to build a compilation pass for circuits. Most of the method contents is just there to define the expectations of the form of the circuit using the tket <code class="xref py py-class docutils literal notranslate"><span class="pre">Predicate</span></code> system, which saves the need for the pass to be fully generic and be constantly maintained to accept arbitrary circuits.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">zx_to_circuit()</span></code> in ZXConverters.cpp implements the extraction procedure. It is advised to read this alongside the algorithm description in Backens et al. for more detail on the intent and intuition around each step.</p></li>
</ul>
<div role="list" class="citation-list">
<div class="citation" id="back2021" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span>Back2021<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>Backens, M. et al., 2021. There and back again: A circuit extraction tale. Quantum, 5, p.451.</p>
</div>
<div class="citation" id="vdwet2020" role="doc-biblioentry">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">vdWet2020</a><span class="fn-bracket">]</span></span>
<p>van de Wetering, J., 2020. ZX-calculus for the working quantum computer scientist. <a class="reference external" href="https://arxiv.org/abs/2012.13966">https://arxiv.org/abs/2012.13966</a></p>
</div>
</div>
</section>
</section>
</section>


                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="manual_assertion.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Assertion</p>
      </div>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#generator-types">Generator Types</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#creating-diagrams">Creating Diagrams</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#tensor-evaluation">Tensor Evaluation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-traversal-inspection-and-manual-rewriting">Graph Traversal, Inspection, and Manual Rewriting</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#built-in-rewrite-passes">Built-in Rewrite Passes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#mbqc-flow-detection">MBQC Flow Detection</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#conversions-extraction">Conversions &amp; Extraction</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compiler-passes-using-zx">Compiler Passes Using ZX</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#advanced-topics">Advanced Topics</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#c-implementation">C++ Implementation</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Cambridge Quantum Computing Ltd
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2020-2023 Cambridge Quantum Computing Ltd.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>